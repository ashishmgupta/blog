{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Overview"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"BlockMiscAzureServices/","text":"We would want to restrict access to various Azure services to non-admin users becuase they dont need that access. Some of those services fall under the umbrella of an in built Azure App named \"Microsoft Azure management\". So, if we block access to this app for non-admin users, the services under them will be unavailable to the non-admin users. Below are the services under \"Microsoft Azure management\". Azure portal Azure Resource Manager provider Classic deployment model APIs Azure PowerShell Azure CLI Azure DevOps Azure Data Factory portal Azure Event Hubs Azure Service Bus Azure SQL Database SQL Managed Instance Azure Synapse Visual Studio subscriptions administrator portal Source : https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/concept-conditional-access-cloud-apps Below is the PowerShell script to create the conditional access policy which would restrict access to above services to all users except admins. # Connect to AzureAD and get current logged in user $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connect now...\"; Write-Host \"You're not connected to AzureAD\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } $AdminRolesIds = Get-AzureADMSROleDefinition | Where-Object -FilterScript {$_.DisplayName -like '*Administrator'}| select -ExpandProperty Id # Create the conditional access policy to block access from all OFAC countries to all apps for all users except the currently logged in user $conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet $conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition $conditions.Applications.IncludeApplications = \"797f4846-ba00-4fd7-ba43-dac1f8f63013\" $conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition $conditions.Users.IncludeUsers = \"all\" $conditions.Users.ExcludeRoles = $AdminRolesIds $controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls $controls._Operator = \"OR\" $controls.BuiltInControls = \"block\" New-AzureADMSConditionalAccessPolicy -DisplayName \"Block Misc Azure apps for non-admin users\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls Write-output \"Conditional Access Policy created.\\r\" We can see the conditional access policy has been created to block ALL users(except those in admin roles) from accessing services included under \"Microsoft Azure Management\"","title":"Block Misc Azure Services for non-admin users"},{"location":"BlockOFACCountries/","text":"In case we have a requirement to block requests from certain countries , we can use conditional policy to achieve the same. As a first step, we create a \"named location\" which has the list of countries we need to block all requests from. Then we create a conditional access policy to use that country list to implement the block. ALL users would be blocked from OFAC countries except the currently logged in user. A useful website to look for ISO codes (among others) for countries is https://countrycode.org . The PowerShell script to create the named location and conditional access policy for the block: # Connect to AzureAD and get current logged in user $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connect now...\"; Write-Host \"You're not connected to AzureAD\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } $NamedLocationPolicyName = \"OFAC Countries\" $NamedLocationPolicy = Get-AzureADMSNamedLocationPolicy | Where-Object {$_.DisplayName -eq $NamedLocationPolicy} if ($NamedLocationPolicy -eq $null) { # Create a named location policy which includes all the OFAC Countries. $NamedLocationPolicy = New-AzureADMSNamedLocationPolicy -OdataType \"#microsoft.graph.countryNamedLocation\" -DisplayName $NamedLocationPolicyName -CountriesAndRegions \"BY\",\"BI\",\"BA\",\"CD\",\"CF\",\"CI\",\"CN\",\"CU\",\"IQ\",\"IR\",\"KP\",\"LR\",\"MD\",\"ME\",\"MK\",\"NI\",\"RU\",\"RS\",\"SD\",\"SS\",\"SY\",\"UA\",\"VE\",\"YE\",\"ZW\",\"AU\" -IncludeUnknownCountriesAndRegions $false Write-Host \"Named location policy : \" + $NamedLocationPolicyName + \" has been created.\" Write-Host \"Countries included : \" + $NamedLocationPolicyName.CountriesAndRegions }else{ Write-Host \"Named location policy : \" + $NamedLocationPolicyName + \" already exists.\" Write-Host \"Countries included : \" + $NamedLocationPolicyName.CountriesAndRegions } # Create the conditional access policy to block access from all OFAC countries to all apps for all users except the currently logged in user $conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet $conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition $conditions.Applications.IncludeApplications = \"all\" $conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition $conditions.Users.IncludeUsers = \"all\" $conditions.Users.ExcludeUsers = $CurrentUserId $conditions.Locations = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessLocationCondition $conditions.Locations.IncludeLocations = $NamedLocationPolicy.Id $controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls $controls._Operator = \"OR\" $controls.BuiltInControls = \"block\" New-AzureADMSConditionalAccessPolicy -DisplayName \"Block OFAC countries\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls The conditional access policy is created. The conditional access policy showing block condition for the location noted in the named location \"OFAC Countries\".","title":"Block OFAC Countries"},{"location":"CreateEmergencyUser/","text":"We protect our users by enforcing Azure MFA. However, Azure MFA has gone down before and we dont want administrators to be locked out of tennat to troubleshoot if this happens again. Therefore, we create a cloud-only \"emergency\" account. This account will be assigned a Global Admin role and wont have the MFA enforced on it. This account should be used ONLY when Azure MFA service is down. Given high privileges on this account, any attempt of usage this emergency login should generate a high alert for Security Opertion Center to validate the legit use. The PowerShell script : $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } $CurrentlyLoggedInUser $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId $EmergencyUserUPNPrefix = \"EmUser\" $UserDisplayName = \"EmergencyUser\" $TenantDomain = $Connection.TenantDomain $OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@')) $OnMicrosoftDomain $UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain $EmUser = $NULL try{ $EmUser = Get-AzureADUser -ObjectId $UserPrincipalName -ErrorAction silentlycontinue write-output(\"Emergency user \" + $UserPrincipalName + ' already exists.') }catch{ write-output(\"Emergency user \" + $UserPrincipalName + ' does not exist. Creating now..') Add-Type -AssemblyName System.Web $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2) $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile $PasswordProfile.Password = $UserPassword $UserPassword $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\" # Adding the new user to Global Admin role Write-output \"Adding the new user to Global Admin r+ole\" $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq \"Global Administrator\"} Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"Username: \" + $UserPrincipalName) Add-Content $temp_file (\"Password: \" + $UserPassword) .\\notepad.exe $temp_file write-output(\"User details written to the file\\r\\n\") } The emergency user is created. The emergency user is assigned the Global Administrator role on permanent basis.","title":"Create Emergency User"},{"location":"DisableBasicAuth/","text":"What is Basic Authentication? User supplied user name and password are joined separated by a colon and base64 encoded. The base64 encoded value is sent as HTTP header named \"Authorization\". For example, if the user enters \"admin\" as user name and \"P@ssw0rd\" as password, the base64 encoded value would be \"YWRtaW46UEBzc3cwcmQ\" The HTTP header would be like the below : Authorization: Basic YWRtaW46UEBzc3cwcmQ Basic/Legacy/Protocols/Authentication???? :-$ Sometimes, It gets very confusing when terms like \"basic\" and \"legacy\" are used for both protocols and auth. Therefore, It is very important to understand the difference between the messaging protocols vs the authentication mechanism. The authentication mechanism is a part of messaging protocol which is also deals with how the messages would be exchanged between client and the server after authentication. Lets look at the IMAP4 protocol. https://datatracker.ietf.org/doc/html/rfc3501 You see the \"Authenticated\" step which means how clients would authenticate to the server and also the \"Selected\" step has the SELECT command selects a mailbox so that messages in the mailbox can be accessed. That \"Authenticated\" step may make use of Basic authentication (like we described above). However, that option of using basic auth should be disabled so clients (potential attackers) cant make use of the same. Why basic auth is discouraged? Since the authentication is possible by simply sending the base64 encoded user name and password, It is more prone to brute force and password spraying attacks. It's possible to send the creds over basic auth over HTTP in which case It may be captured by an attacker and decoded back to original plain text credentials. We create an authentication policy that has by default basic auth disabled for all protocols. And then set the default authentication policy for the whole organization the newly created authentication policy New-AuthenticationPolicy -Name \"Block Legacy Auth for all protocols\" By default, the basic auth is disabled for all protocols. Setting the newly created policy with basic auth disabled as the default policy for the organization/tenant. Set-OrganizationConfig -DefaultAuthenticationPolicy \"Block Legacy Auth for all protocols\" Check the newly created authentication policy : The default authentication policy is set to the newly created authentication policy. Get-OrganizationConfig | select DefaultAuthenticationPolicy We can also check the Microsoft Admin Center. Go to Microsoft 365 Admin Center Settings > Org Settings > Modern Authentication All the settings except the \"Turn on modern authentication for Outlook 2013 for Windows and later (recommended)\" should be unchecked. Tests The Python Script To test the basic authentication, we will make use of the below script which tries to authenticate to Exchange Online with a given set of users using Exchange Web Services (EWS). EWS uses Autodiscover protocol which in turn could use basic authentication. The script can be found here as well: https://github.com/ashishmgupta/pyAbuseLegacyAuthInEXO from exchangelib import Credentials, Account import requests import os from pathlib import Path import re external_ip = requests.get('https://ident.me').text print(external_ip) current_dir = os.getcwd() creds_file = os.path.join(current_dir, \"creds.txt\") if not os.path.isfile(creds_file): fp = open('creds_file', 'x') fp.close() print(\"Credentials file did not exist. We created a new one. Please populate with username and password separated by || in each line\") quit() with open(creds_file) as f: lines = f.readlines() for line in lines: line = line.rstrip() cred = line.split(\"||\") username = cred[0] password = cred[1] print(username) print(password) credentials = Credentials(username, password) account = Account(username, credentials=credentials, autodiscover=True) user_folder= current_dir+\"/\"+username Path(user_folder).mkdir(parents=True, exist_ok=True) for msg in account.inbox.all().order_by('-datetime_received')[:10]: email_content=\"\" clean_subject = re.sub('[^A-Za-z0-9]+','', msg.subject ) msg_folder_to_save = user_folder +\"/\"+clean_subject msg_contents_file = msg_folder_to_save +\"/msg.txt\" Path(msg_folder_to_save).mkdir(parents=True, exist_ok=True) #print(msg.subject, msg.sender, msg.datetime_received) email_content += \"sender ={}\".format(msg.sender) + \"\\n\" email_content += \"datetime_sent ={}\".format(msg.datetime_sent)+ \"\\n\" email_content += \"subject ={}\".format(msg.subject)+ \"\\n\" email_content += \"text_body ={}\".format(msg.text_body.encode('UTF-8'))+ \"\\n\" with open(msg_contents_file, \"w+\") as f: f.write(email_content) print(email_content) print(\"#\" * 80) for attachment in msg.attachments: fpath = os.path.join(msg_folder_to_save, attachment.name) with open(fpath, 'wb') as f: f.write(attachment.content) Enabling the basic auth for all protocols Set-AuthenticationPolicy -Identity 'Block Legacy Auth for all protocols' -AllowBasicAuthAutodiscover -AllowBasicAuthActiveSync -AllowBasicAuthImap -AllowBasicAuthMapi -AllowBasicAuthOfflineAddressBook -AllowBasicAuthOutlookService -AllowBasicAuthPop -AllowBasicAuthPowershell -AllowBasicAuthReportingWebServices -AllowBasicAuthRpc -AllowBasicAuthSmtp -AllowBasicAuthWebServices Basic auth enabled for all protocols. Executing the Python script. Could retrieve all the messages from the mailbox. Disabling the basic auth for all protocols Set-AuthenticationPolicy -Identity 'Block Legacy Auth for all protocols' -AllowBasicAuthAutodiscover:$false -AllowBasicAuthActiveSync:$false -AllowBasicAuthImap:$false -AllowBasicAuthMapi:$false -AllowBasicAuthOfflineAddressBook:$false -AllowBasicAuthOutlookService:$false -AllowBasicAuthPop:$false -AllowBasicAuthPowershell:$false -AllowBasicAuthReportingWebServices:$false -AllowBasicAuthRpc:$false -AllowBasicAuthSmtp:$false -AllowBasicAuthWebServices:$false Basic auth disabled for all protocols. The test will fail with below error : exchangelib.errors.AutoDiscoverFailed: All steps in the autodiscover protocol failed for email 'email'. If you think this is an error, consider doing an official test at https://testconnectivity.microsoft.com","title":"Disable basic authentication"},{"location":"DisableBasicAuth/#what-is-basic-authentication","text":"","title":"What is Basic Authentication?"},{"location":"DisableBasicAuth/#basiclegacyprotocolsauthentication-","text":"Sometimes, It gets very confusing when terms like \"basic\" and \"legacy\" are used for both protocols and auth. Therefore, It is very important to understand the difference between the messaging protocols vs the authentication mechanism. The authentication mechanism is a part of messaging protocol which is also deals with how the messages would be exchanged between client and the server after authentication. Lets look at the IMAP4 protocol. https://datatracker.ietf.org/doc/html/rfc3501 You see the \"Authenticated\" step which means how clients would authenticate to the server and also the \"Selected\" step has the SELECT command selects a mailbox so that messages in the mailbox can be accessed. That \"Authenticated\" step may make use of Basic authentication (like we described above). However, that option of using basic auth should be disabled so clients (potential attackers) cant make use of the same.","title":"Basic/Legacy/Protocols/Authentication???? :-$"},{"location":"DisableBasicAuth/#why-basic-auth-is-discouraged","text":"Since the authentication is possible by simply sending the base64 encoded user name and password, It is more prone to brute force and password spraying attacks. It's possible to send the creds over basic auth over HTTP in which case It may be captured by an attacker and decoded back to original plain text credentials. We create an authentication policy that has by default basic auth disabled for all protocols. And then set the default authentication policy for the whole organization the newly created authentication policy New-AuthenticationPolicy -Name \"Block Legacy Auth for all protocols\" By default, the basic auth is disabled for all protocols. Setting the newly created policy with basic auth disabled as the default policy for the organization/tenant. Set-OrganizationConfig -DefaultAuthenticationPolicy \"Block Legacy Auth for all protocols\" Check the newly created authentication policy : The default authentication policy is set to the newly created authentication policy. Get-OrganizationConfig | select DefaultAuthenticationPolicy We can also check the Microsoft Admin Center. Go to Microsoft 365 Admin Center Settings > Org Settings > Modern Authentication All the settings except the \"Turn on modern authentication for Outlook 2013 for Windows and later (recommended)\" should be unchecked.","title":"Why basic auth is discouraged?"},{"location":"DisableBasicAuth/#tests","text":"","title":"Tests"},{"location":"DisableBasicAuth/#the-python-script","text":"To test the basic authentication, we will make use of the below script which tries to authenticate to Exchange Online with a given set of users using Exchange Web Services (EWS). EWS uses Autodiscover protocol which in turn could use basic authentication. The script can be found here as well: https://github.com/ashishmgupta/pyAbuseLegacyAuthInEXO from exchangelib import Credentials, Account import requests import os from pathlib import Path import re external_ip = requests.get('https://ident.me').text print(external_ip) current_dir = os.getcwd() creds_file = os.path.join(current_dir, \"creds.txt\") if not os.path.isfile(creds_file): fp = open('creds_file', 'x') fp.close() print(\"Credentials file did not exist. We created a new one. Please populate with username and password separated by || in each line\") quit() with open(creds_file) as f: lines = f.readlines() for line in lines: line = line.rstrip() cred = line.split(\"||\") username = cred[0] password = cred[1] print(username) print(password) credentials = Credentials(username, password) account = Account(username, credentials=credentials, autodiscover=True) user_folder= current_dir+\"/\"+username Path(user_folder).mkdir(parents=True, exist_ok=True) for msg in account.inbox.all().order_by('-datetime_received')[:10]: email_content=\"\" clean_subject = re.sub('[^A-Za-z0-9]+','', msg.subject ) msg_folder_to_save = user_folder +\"/\"+clean_subject msg_contents_file = msg_folder_to_save +\"/msg.txt\" Path(msg_folder_to_save).mkdir(parents=True, exist_ok=True) #print(msg.subject, msg.sender, msg.datetime_received) email_content += \"sender ={}\".format(msg.sender) + \"\\n\" email_content += \"datetime_sent ={}\".format(msg.datetime_sent)+ \"\\n\" email_content += \"subject ={}\".format(msg.subject)+ \"\\n\" email_content += \"text_body ={}\".format(msg.text_body.encode('UTF-8'))+ \"\\n\" with open(msg_contents_file, \"w+\") as f: f.write(email_content) print(email_content) print(\"#\" * 80) for attachment in msg.attachments: fpath = os.path.join(msg_folder_to_save, attachment.name) with open(fpath, 'wb') as f: f.write(attachment.content)","title":"The Python Script"},{"location":"DisableBasicAuth/#enabling-the-basic-auth-for-all-protocols","text":"Set-AuthenticationPolicy -Identity 'Block Legacy Auth for all protocols' -AllowBasicAuthAutodiscover -AllowBasicAuthActiveSync -AllowBasicAuthImap -AllowBasicAuthMapi -AllowBasicAuthOfflineAddressBook -AllowBasicAuthOutlookService -AllowBasicAuthPop -AllowBasicAuthPowershell -AllowBasicAuthReportingWebServices -AllowBasicAuthRpc -AllowBasicAuthSmtp -AllowBasicAuthWebServices Basic auth enabled for all protocols. Executing the Python script. Could retrieve all the messages from the mailbox.","title":"Enabling the basic auth for all protocols "},{"location":"DisableBasicAuth/#disabling-the-basic-auth-for-all-protocols","text":"Set-AuthenticationPolicy -Identity 'Block Legacy Auth for all protocols' -AllowBasicAuthAutodiscover:$false -AllowBasicAuthActiveSync:$false -AllowBasicAuthImap:$false -AllowBasicAuthMapi:$false -AllowBasicAuthOfflineAddressBook:$false -AllowBasicAuthOutlookService:$false -AllowBasicAuthPop:$false -AllowBasicAuthPowershell:$false -AllowBasicAuthReportingWebServices:$false -AllowBasicAuthRpc:$false -AllowBasicAuthSmtp:$false -AllowBasicAuthWebServices:$false Basic auth disabled for all protocols. The test will fail with below error : exchangelib.errors.AutoDiscoverFailed: All steps in the autodiscover protocol failed for email 'email'. If you think this is an error, consider doing an official test at https://testconnectivity.microsoft.com","title":"Disabling the basic auth for all protocols "},{"location":"DisableSMTPAuth/","text":"Tests Below code tries to use Basic Auth over SMTP Auth protocol and fails becuase SMTP Auth is disabled $creds = get-credential Send-MailMessage \u2013From donaldblake@redteamsimulation.com \u2013To ashishxxx@xxx.com \u2013Subject \"Test Email\" \u2013Body \"Test SMTP Service from Powershell\" -SmtpServer smtp.office365.com -Credential $creds -UseSsl -Port 587 Error Message : Send-MailMessage : The SMTP server requires a secure connection or the client was not authenticated. The server response was: 5.7.57 Client not authenticated to send mail. Error: 535 5.7.139 Authentication unsuccessful, SmtpClientAuthentication is disabled for the Tenant. Visit https://aka.ms/smtp_auth_disabled for more information. [BN0PR10CA0026.namprd10.prod.outlook.com] At line:1 char:1 + Send-MailMessage \u2013From donaldblake@redteamsimulation.com \u2013To ashishmg ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidOperation: (System.Net.Mail.SmtpClient:SmtpClient) [Send-MailMessage], SmtpExcept ion + FullyQualifiedErrorId : SmtpException,Microsoft.PowerShell.Commands.SendMailMessage","title":"Disable SMTP Auth"},{"location":"DisableSMTPAuth/#tests","text":"Below code tries to use Basic Auth over SMTP Auth protocol and fails becuase SMTP Auth is disabled $creds = get-credential Send-MailMessage \u2013From donaldblake@redteamsimulation.com \u2013To ashishxxx@xxx.com \u2013Subject \"Test Email\" \u2013Body \"Test SMTP Service from Powershell\" -SmtpServer smtp.office365.com -Credential $creds -UseSsl -Port 587 Error Message : Send-MailMessage : The SMTP server requires a secure connection or the client was not authenticated. The server response was: 5.7.57 Client not authenticated to send mail. Error: 535 5.7.139 Authentication unsuccessful, SmtpClientAuthentication is disabled for the Tenant. Visit https://aka.ms/smtp_auth_disabled for more information. [BN0PR10CA0026.namprd10.prod.outlook.com] At line:1 char:1 + Send-MailMessage \u2013From donaldblake@redteamsimulation.com \u2013To ashishmg ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidOperation: (System.Net.Mail.SmtpClient:SmtpClient) [Send-MailMessage], SmtpExcept ion + FullyQualifiedErrorId : SmtpException,Microsoft.PowerShell.Commands.SendMailMessage","title":"Tests"},{"location":"DisableSecurityDefaults/","text":"Security Defaults is a set of basic identity security mechanisms recommended by Microsoft. When enabled, these recommendations will be automatically enforced in your organization. Source: https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/concept-fundamentals-security-defaults That said, to be more flexible and wider security controls, you would use conditional access policies which require the security defaults to be disabled. Login to Azure portal > Azure Active Directory > Properties > Manage Security Defaults > Enable Security Defaults > set to \"No\"","title":"Disable Security Defaults"},{"location":"EnableSelfServicePasswordReset/","text":"","title":"Enable Self Service Password Reset"},{"location":"ImplementMFA/","text":"PowerShell to create a conditional Acesss Policy to enforce all MFA on all users excluding an emergency Azure cloud-only Account. $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } $CurrentlyLoggedInUser $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId $EmergencyUserUPNPrefix = \"EmUser\" $UserDisplayName = \"EmergencyUser\" $TenantDomain = $Connection.TenantDomain $OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@')) $OnMicrosoftDomain $UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain $EmUser = $NULL try{ $EmUser = Get-AzureADUser -ObjectId $UserPrincipalName -ErrorAction silentlycontinue write-output(\"Emergency user \" + $UserPrincipalName + ' already exists.') }catch{ write-output(\"Emergency user \" + $UserPrincipalName + ' does not exist. Creating now..') Add-Type -AssemblyName System.Web $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2) $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile $PasswordProfile.Password = $UserPassword $UserPassword $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\" # Adding the new user to Global Admin role Write-output \"Adding the new user to Global Admin r+ole\" $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq \"Global Administrator\"} Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"Username: \" + $UserPrincipalName) Add-Content $temp_file (\"Password: \" + $UserPassword) .\\notepad.exe $temp_file write-output(\"User details written to the file\\r\\n\") } $conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet $conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition $conditions.Applications.IncludeApplications = \"all\" $conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition $conditions.Users.IncludeUsers = \"all\" $conditions.Users.ExcludeUsers = $EmUser.ObjectId $controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls $controls._Operator = \"OR\" $controls.BuiltInControls = \"mfa\" New-AzureADMSConditionalAccessPolicy -DisplayName \"Enforce MFA on all users\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls Write-Output \"Conditional Access policy created\" Conditional Access policy is created. MFA is enforced for all apps. MFA is enforced for all users except the emergency global admin user.","title":"Implement MFA"},{"location":"MITRE-ATT%26CK-O365/","text":"https://attack.mitre.org/matrices/enterprise/cloud/office365/ Tactics: Initial Access Techniques Phishing (URL rewriting, Proofpoint/Mimecast) Valid Accounts Persistence Techniques Account Manipulation Grant additional email delegate permissions Add-MailboxPermission -User admin@contoso.com -AccessRights FullAccess -InheritanceType All Create Account Splunk detection of creating a user with onmicrosoft.com domain name. Office Application Startup Valid Accounts Privilege Escalation Techniques Valid Accounts Defense Evasion Techniques Hide Artifacts Impair Defenses Use Alternate Authentication material Valid Accounts Credential Access Techniques Brute Force Force Web Credentials Multi-factor Authentication request Generation Steal Application Access Token Steal Web Session Cookie Unsecured Credentials Discovery Techniques Internal Spearphishing Taint Shared Content Use Alternate Authentication Material Collection Techniques Data from Information repositories Email Collection Impact Techniques Account Access removal Endpoint Denial of Service Network Denial of Service","title":"MITRE ATT&CK O365"},{"location":"RestrictExtarnelCollaboration/","text":"If there is no business use case for external collaboration, set it to most restrictive settings. Azure Portal > Azure Active Directory > External Identities > Extarnel Collaboration Settings","title":"Restrict External Collaboration"},{"location":"RestrictUserSettings/","text":"Restrict registration of new Azure AD applications It is important to control registration of Azure AD applications. Azure Portal > Azure Active Directory > User Settings Restrict users' ability to consent to Apps. It is important to restrict users' ability to consent for applications to access organization data With the below setting, we allow user consent only for applications that have been published by a verified publisher. Set-AzureADMSAuthorizationPolicy -DefaultUserRolePermissions @{\"PermissionGrantPoliciesAssigned\" = @(\"managePermissionGrantsForSelf.microsoft-user-default-low\") } When an application is marked as publisher verified, it means that the publisher has verified their identity using a Microsoft Partner Network account that has completed the verification process and has associated this MPN account with their application registration. Source : Publisher verification overview","title":"Restrict User Settings"},{"location":"RestrictUserSettings/#restrict-registration-of-new-azure-ad-applications","text":"It is important to control registration of Azure AD applications. Azure Portal > Azure Active Directory > User Settings","title":"Restrict registration of new Azure AD applications"},{"location":"RestrictUserSettings/#restrict-users-ability-to-consent-to-apps","text":"It is important to restrict users' ability to consent for applications to access organization data With the below setting, we allow user consent only for applications that have been published by a verified publisher. Set-AzureADMSAuthorizationPolicy -DefaultUserRolePermissions @{\"PermissionGrantPoliciesAssigned\" = @(\"managePermissionGrantsForSelf.microsoft-user-default-low\") } When an application is marked as publisher verified, it means that the publisher has verified their identity using a Microsoft Partner Network account that has completed the verification process and has associated this MPN account with their application registration. Source : Publisher verification overview","title":"Restrict users' ability to consent to Apps."},{"location":"SMTPAuthTests/","text":"# Sender Credentials # Sender and Recipient Info $MailFrom = \"ashish.gupta@lplfinancial.com\" $MailTo = \"ashishmgupta@hotmail.com\" $Username = \"infosec.test@lplfinancial.com\" $Password = \"bN1A&Fwf018s8huq%Aff\" # Server Info $SmtpServer = \"smtp.office365.com\" $SmtpPort = \"587\" # Message stuff $MessageSubject = \"Microsoft .NET documentation\" $Message = New-Object System.Net.Mail.MailMessage $MailFrom,$MailTo $Message.IsBodyHTML = $true $Message.Subject = $MessageSubject $Message.Body = @' <!DOCTYPE html> <html> <head> </head> <body> https://docs.microsoft.com </body> </html> '@ # Construct the SMTP client object, credentials, and send $Smtp = New-Object Net.Mail.SmtpClient($SmtpServer,$SmtpPort) $Smtp.EnableSsl = $true $Smtp.Credentials = New-Object System.Net.NetworkCredential($Username,$Password) $Smtp.Send($Message)","title":"SMTPAuthTests"},{"location":"SetupAzureADAppForSplunk/","text":"This section covers setting up an Azure AD app for Splunk Add-on so O365 logs could be ingested in Splunk. Below script would create the app so It does not need to be created manually. The admin consent needs to be granted via the Azure portal (instructions below). The details for the newly created app needs to be provided to the Splunk Administrator so they could set up the Azure tenant for the log ingestion. Step 0 - Install Azure AD Powershell Please execute the below in PowerShell to install the Azure AD module for Powershell Install-Module AzureAD Please ensure you are executing the above in Powershell v5.1 and not 7.x. Execute the below to ensure : $PSVersionTable Step 1 - PowerShell script to Create the app Please ensure you are in the Global Administrator role in the tenant. The script may prompt you to login. Open Powershell as administrator. Copy the script by clicking on the copy icon in script below. Paste the script on the Powershell window and hit enter. # Author - Ashish Gupta # This script creates a new Azure AD application and sets the Application and Delegated permissions for specific API (O365) $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } $CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\") $ApplicationDisplayName = \"Splunk App for Office 365\" $AzureADAppForSplunk = Get-AzureADApplication -Filter \"DisplayName eq '$ApplicationDisplayName'\" if($AzureADAppForSplunk -eq $NULL) { write-output(\"AzureAD application \" + $ApplicationDisplayName + \" does not exist. Creating...\") # Get the service principal for O365 and Microsoft Graph $ServicePrincipalO365API = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Office 365 Management APIs\" } $ServicePrincipalMicrosoftGraph = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Microsoft Graph\" } # Get all application permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphAppRoles = $ServicePrincipalMicrosoftGraph.AppRoles | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all delegated permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphDelegatedRoles = $ServicePrincipalMicrosoftGraph.Oauth2Permissions | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all application permissions for O365 API $ServicePrincipalO365APIAppRoles = $ServicePrincipalO365API.AppRoles | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Get all delegated permissions for O365 API $ServicePrincipalO365APIDelegatedRoles = $ServicePrincipalO365API.Oauth2Permissions | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Create a Required Resource Access object for Office 365 $RequiredResourceAccessO365API = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessO365API.ResourceAppId = $ServicePrincipalO365API.AppId # Create a Required Resource Access object for Microsoft Graph $RequiredResourceAccessMicrosoftGraph = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessMicrosoftGraph.ResourceAppId = $ServicePrincipalMicrosoftGraph.AppId $ServicePrincipalO365APIAppRolesSelectedPermissions = @() $ServicePrincipalSelectedPermissionsMicrosoftGraph = @() # Get all the Resource Access objects for the Application permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Application permissions for Office 365 API\" foreach ($ServicePrincipalO365APIAppRole in $ServicePrincipalO365APIAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIAppRole.Id,\"Role\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Delegated permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Delegated permissions for Office 365 API\" foreach ($ServicePrincipalO365APIDelegatedRole in $ServicePrincipalO365APIDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIDelegatedRole.Id,\"Scope\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Application permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Application permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphAppRole in $ServicePrincipalMicrosoftGraphAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphAppRole.Id,\"Role\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphDelegatedRole in $ServicePrincipalMicrosoftGraphDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphDelegatedRole.Id,\"Scope\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Assign all the permissions to the required Resource access for the O365 API $RequiredResourceAccessO365API.ResourceAccess = $ServicePrincipalO365APIAppRolesSelectedPermissions # Assign all the permissions to the required Resource access for the Microsoft Graph $RequiredResourceAccessMicrosoftGraph.ResourceAccess = $ServicePrincipalSelectedPermissionsMicrosoftGraph # Create the Password credential for the new app Add-Type -AssemblyName System.Web $ApplicationPassword =[System.Web.Security.Membership]::GeneratePassword(32,2) $ApplicationPassword = $ApplicationPassword.Replace(\"+\",\"_\") $ApplicationPassword = $ApplicationPassword.Replace(\"-\",\"_\") $keyId = (New-Guid).ToString(); $fromDate = [System.DateTime]::Now $durationInYears = 5 $endDate = $fromDate.AddYears($durationInYears) $Applicationkey = New-Object Microsoft.Open.AzureAD.Model.PasswordCredential($null, $endDate, $keyId, $fromDate, $ApplicationPassword) # Create the new app with the password cred $aadApplication = New-AzureADApplication -DisplayName $ApplicationDisplayName -PasswordCredentials $Applicationkey write-output(\"Application created\") # Set the permissions Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $RequiredResourceAccessO365API,$RequiredResourceAccessMicrosoftGraph write-output(\"Application permissions set\") # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Azure AD App display name: \" + $aadApplication.DisplayName) Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"App ClientId: \" + $aadApplication.AppId) Add-Content $temp_file (\"App Password: \" + $ApplicationPassword) .\\notepad.exe $temp_file write-output(\"Application details written to the file\") }else{ write-output(\"AzureAD application '\" + $AzureADAppForSplunk.DisplayName + \"' already exists.\") } The powershell script got executed and we can see the newly created app in the Azure portal: Step 2 - Provide app details to Splunk Admin The details for the newly created app is opened in the Notepad. This should be sent to the Splunk Administrator so they could set up the Splunk Add-on for O365 for this tenant. Step 3 - Grant Admin Consent in Azure Portal Log in to the Azure portal as Global Administrator. Navigate to Azure Active Directory > App Registrations > Click on \"All Applications\" > Go to \"Splunk app for Office 365\". In the app, click on \"API Permissions\". Notice all the permissions have already been assigned via the script. Click on \"Grant admin consent for tenant\" After the admin consent grant, It should look like below :","title":"Setup AzureAD App For Splunk"},{"location":"SetupAzureADAppForSplunk/#step-0-install-azure-ad-powershell","text":"Please execute the below in PowerShell to install the Azure AD module for Powershell Install-Module AzureAD Please ensure you are executing the above in Powershell v5.1 and not 7.x. Execute the below to ensure : $PSVersionTable","title":"Step 0 - Install Azure AD Powershell"},{"location":"SetupAzureADAppForSplunk/#step-1-powershell-script-to-create-the-app","text":"Please ensure you are in the Global Administrator role in the tenant. The script may prompt you to login. Open Powershell as administrator. Copy the script by clicking on the copy icon in script below. Paste the script on the Powershell window and hit enter. # Author - Ashish Gupta # This script creates a new Azure AD application and sets the Application and Delegated permissions for specific API (O365) $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } $CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\") $ApplicationDisplayName = \"Splunk App for Office 365\" $AzureADAppForSplunk = Get-AzureADApplication -Filter \"DisplayName eq '$ApplicationDisplayName'\" if($AzureADAppForSplunk -eq $NULL) { write-output(\"AzureAD application \" + $ApplicationDisplayName + \" does not exist. Creating...\") # Get the service principal for O365 and Microsoft Graph $ServicePrincipalO365API = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Office 365 Management APIs\" } $ServicePrincipalMicrosoftGraph = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Microsoft Graph\" } # Get all application permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphAppRoles = $ServicePrincipalMicrosoftGraph.AppRoles | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all delegated permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphDelegatedRoles = $ServicePrincipalMicrosoftGraph.Oauth2Permissions | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all application permissions for O365 API $ServicePrincipalO365APIAppRoles = $ServicePrincipalO365API.AppRoles | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Get all delegated permissions for O365 API $ServicePrincipalO365APIDelegatedRoles = $ServicePrincipalO365API.Oauth2Permissions | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Create a Required Resource Access object for Office 365 $RequiredResourceAccessO365API = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessO365API.ResourceAppId = $ServicePrincipalO365API.AppId # Create a Required Resource Access object for Microsoft Graph $RequiredResourceAccessMicrosoftGraph = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessMicrosoftGraph.ResourceAppId = $ServicePrincipalMicrosoftGraph.AppId $ServicePrincipalO365APIAppRolesSelectedPermissions = @() $ServicePrincipalSelectedPermissionsMicrosoftGraph = @() # Get all the Resource Access objects for the Application permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Application permissions for Office 365 API\" foreach ($ServicePrincipalO365APIAppRole in $ServicePrincipalO365APIAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIAppRole.Id,\"Role\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Delegated permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Delegated permissions for Office 365 API\" foreach ($ServicePrincipalO365APIDelegatedRole in $ServicePrincipalO365APIDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIDelegatedRole.Id,\"Scope\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Application permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Application permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphAppRole in $ServicePrincipalMicrosoftGraphAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphAppRole.Id,\"Role\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphDelegatedRole in $ServicePrincipalMicrosoftGraphDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphDelegatedRole.Id,\"Scope\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Assign all the permissions to the required Resource access for the O365 API $RequiredResourceAccessO365API.ResourceAccess = $ServicePrincipalO365APIAppRolesSelectedPermissions # Assign all the permissions to the required Resource access for the Microsoft Graph $RequiredResourceAccessMicrosoftGraph.ResourceAccess = $ServicePrincipalSelectedPermissionsMicrosoftGraph # Create the Password credential for the new app Add-Type -AssemblyName System.Web $ApplicationPassword =[System.Web.Security.Membership]::GeneratePassword(32,2) $ApplicationPassword = $ApplicationPassword.Replace(\"+\",\"_\") $ApplicationPassword = $ApplicationPassword.Replace(\"-\",\"_\") $keyId = (New-Guid).ToString(); $fromDate = [System.DateTime]::Now $durationInYears = 5 $endDate = $fromDate.AddYears($durationInYears) $Applicationkey = New-Object Microsoft.Open.AzureAD.Model.PasswordCredential($null, $endDate, $keyId, $fromDate, $ApplicationPassword) # Create the new app with the password cred $aadApplication = New-AzureADApplication -DisplayName $ApplicationDisplayName -PasswordCredentials $Applicationkey write-output(\"Application created\") # Set the permissions Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $RequiredResourceAccessO365API,$RequiredResourceAccessMicrosoftGraph write-output(\"Application permissions set\") # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Azure AD App display name: \" + $aadApplication.DisplayName) Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"App ClientId: \" + $aadApplication.AppId) Add-Content $temp_file (\"App Password: \" + $ApplicationPassword) .\\notepad.exe $temp_file write-output(\"Application details written to the file\") }else{ write-output(\"AzureAD application '\" + $AzureADAppForSplunk.DisplayName + \"' already exists.\") } The powershell script got executed and we can see the newly created app in the Azure portal:","title":"Step 1 - PowerShell script to Create the app"},{"location":"SetupAzureADAppForSplunk/#step-2-provide-app-details-to-splunk-admin","text":"The details for the newly created app is opened in the Notepad. This should be sent to the Splunk Administrator so they could set up the Splunk Add-on for O365 for this tenant.","title":"Step 2 - Provide app details to Splunk Admin"},{"location":"SetupAzureADAppForSplunk/#step-3-grant-admin-consent-in-azure-portal","text":"Log in to the Azure portal as Global Administrator. Navigate to Azure Active Directory > App Registrations > Click on \"All Applications\" > Go to \"Splunk app for Office 365\". In the app, click on \"API Permissions\". Notice all the permissions have already been assigned via the script. Click on \"Grant admin consent for tenant\" After the admin consent grant, It should look like below :","title":"Step 3 - Grant Admin Consent in Azure Portal"}]}