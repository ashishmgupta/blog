{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Overview"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"BlockOFACCountries/","text":"In case we have a requirement to block requests from certain countries , we can use conditional policy to achieve the same. As a first step, we create a \"named location\" which has the list of countries we need to block all requests from. Then we create a conditional access policy to use that country list to implement the block. ALL users would be blocked from OFAC countries except the currently logged in user. A useful website to look for ISO codes (among others) for countries is https://countrycode.org . The PowerShell script to create the named location and conditional access policy for the block: # Connect to AzureAD and get current logged in user $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connect now...\"; Write-Host \"You're not connected to AzureAD\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } $NamedLocationPolicyName = \"OFAC Countries\" $NamedLocationPolicy = Get-AzureADMSNamedLocationPolicy | Where-Object {$_.DisplayName -eq $NamedLocationPolicy} if ($NamedLocationPolicy -eq $null) { # Create a named location policy which includes all the OFAC Countries. $NamedLocationPolicy = New-AzureADMSNamedLocationPolicy -OdataType \"#microsoft.graph.countryNamedLocation\" -DisplayName $NamedLocationPolicyName -CountriesAndRegions \"BY\",\"BI\",\"BA\",\"CD\",\"CF\",\"CI\",\"CN\",\"CU\",\"IQ\",\"IR\",\"KP\",\"LR\",\"MD\",\"ME\",\"MK\",\"NI\",\"RU\",\"RS\",\"SD\",\"SS\",\"SY\",\"UA\",\"VE\",\"YE\",\"ZW\",\"AU\" -IncludeUnknownCountriesAndRegions $false Write-Host \"Named location policy : \" + $NamedLocationPolicyName + \" has been created.\" Write-Host \"Countries included : \" + $NamedLocationPolicyName.CountriesAndRegions }else{ Write-Host \"Named location policy : \" + $NamedLocationPolicyName + \" already exists.\" Write-Host \"Countries included : \" + $NamedLocationPolicyName.CountriesAndRegions } # Create the conditional access policy to block access from all OFAC countries to all apps for all users except the currently logged in user $conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet $conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition $conditions.Applications.IncludeApplications = \"all\" $conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition $conditions.Users.IncludeUsers = \"all\" $conditions.Users.ExcludeUsers = $CurrentUserId $conditions.Locations = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessLocationCondition $conditions.Locations.IncludeLocations = $NamedLocationPolicy.Id $controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls $controls._Operator = \"OR\" $controls.BuiltInControls = \"block\" New-AzureADMSConditionalAccessPolicy -DisplayName \"Block OFAC countries\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls The conditional access policy is created. The conditional access policy showing block condition for the location noted in the named location \"OFAC Countries\".","title":"Block OFAC Countries"},{"location":"CreateEmergencyUser/","text":"We protect our users by enforcing Azure MFA. However, Azure MFA has gone down before and we dont want administrators to be locked out of tennat to troubleshoot if this happens again. Therefore, we create a cloud-only \"emergency\" account. This account will be assigned a Global Admin role and wont have the MFA enforced on it. This account should be used ONLY when Azure MFA service is down. Given high privileges on this account, any attempt of usage this emergency login should generate a high alert for Security Opertion Center to validate the legit use. The PowerShell script : $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } $CurrentlyLoggedInUser $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId $EmergencyUserUPNPrefix = \"EmUser\" $UserDisplayName = \"EmergencyUser\" $TenantDomain = $Connection.TenantDomain $OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@')) $OnMicrosoftDomain $UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain $EmUser = $NULL try{ $EmUser = Get-AzureADUser -ObjectId $UserPrincipalName -ErrorAction silentlycontinue write-output(\"Emergency user \" + $UserPrincipalName + ' already exists.') }catch{ write-output(\"Emergency user \" + $UserPrincipalName + ' does not exist. Creating now..') Add-Type -AssemblyName System.Web $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2) $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile $PasswordProfile.Password = $UserPassword $UserPassword $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\" # Adding the new user to Global Admin role Write-output \"Adding the new user to Global Admin r+ole\" $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq \"Global Administrator\"} Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"Username: \" + $UserPrincipalName) Add-Content $temp_file (\"Password: \" + $UserPassword) .\\notepad.exe $temp_file write-output(\"User details written to the file\\r\\n\") } The emergency user is created. The emergency user is assigned the Global Administrator role on permanent basis.","title":"Create Emergency User"},{"location":"DisableBasicAuth/","text":"What is Basic Authentication? User supplied user name and password are joined separated by a colon and base64 encoded. The base64 encoded value is sent as an HTTP header named \"Authorization\". For example, if the user enters \"admin\" as user name and \"P@ssw0rd\" as password, the base64 encoded value would be \"YWRtaW46UEBzc3cwcmQ\" The HTTP header would be like the below : Authorization: Basic YWRtaW46UEBzc3cwcmQ It's possible to send the creds over basic auth over HTTP in which case It may be captured by an attacker and decoded back to original plain text credentials. We create an authentication policy which has by default basic auth disabled for all protocols. And the set the default authentication policy for the whole organization the newly created authentication policy New-AuthenticationPolicy -Name \"Block Legacy Auth for all protocols\" By defualt, the basic auth is disabled for all protocols. Setting the newly created policy with basic auth disabled as the default policy for the organization/tenant. Set-OrganizationConfig -DefaultAuthenticationPolicy \"Block Legacy Auth for all protocols\" Check the newly created authentication policy : The default authentication policy is set to the newly created authentication policy. Get-OrganizationConfig | select DefaultAuthenticationPolicy We can also check the Microsoft Admin Center. Go to Microsoft 365 Admin Center Settings > Org Settings > Modern Authentication All the settings except the \"Turn on modern authentication for Outlook 2013 for Windows and later (recommended)\" should be unchecked. Tests The Python Script In order to test the basic authentication, we will make use of the below script which tries to authenticate to Exchange Online with a given set of users using Exchange Web Services (EWS). EWS uses Autodiscover protocol which in turn could use basic authentication. from exchangelib import Credentials, Account import requests import os from pathlib import Path import re external_ip = requests.get('https://ident.me').text print(external_ip) current_dir = os.getcwd() creds_file = os.path.join(current_dir, \"creds.txt\") if not os.path.isfile(creds_file): fp = open('creds_file', 'x') fp.close() print(\"Credentials file did not exist. We created a new one. Please populate with username and password separated by || in each line\") quit() with open(creds_file) as f: lines = f.readlines() for line in lines: line = line.rstrip() cred = line.split(\"||\") username = cred[0] password = cred[1] print(username) print(password) credentials = Credentials(username, password) account = Account(username, credentials=credentials, autodiscover=True) user_folder= current_dir+\"/\"+username Path(user_folder).mkdir(parents=True, exist_ok=True) for msg in account.inbox.all().order_by('-datetime_received')[:10]: email_content=\"\" clean_subject = re.sub('[^A-Za-z0-9]+','', msg.subject ) msg_folder_to_save = user_folder +\"/\"+clean_subject msg_contents_file = msg_folder_to_save +\"/msg.txt\" Path(msg_folder_to_save).mkdir(parents=True, exist_ok=True) #print(msg.subject, msg.sender, msg.datetime_received) email_content += \"sender ={}\".format(msg.sender) + \"\\n\" email_content += \"datetime_sent ={}\".format(msg.datetime_sent)+ \"\\n\" email_content += \"subject ={}\".format(msg.subject)+ \"\\n\" email_content += \"text_body ={}\".format(msg.text_body.encode('UTF-8'))+ \"\\n\" with open(msg_contents_file, \"w+\") as f: f.write(email_content) print(email_content) print(\"#\" * 80) for attachment in msg.attachments: fpath = os.path.join(msg_folder_to_save, attachment.name) with open(fpath, 'wb') as f: f.write(attachment.content) Enabling the basic auth for all protocols : Set-AuthenticationPolicy -Identity 'Block Legacy Auth for all protocols' -AllowBasicAuthAutodiscover -AllowBasicAuthActiveSync -AllowBasicAuthImap -AllowBasicAuthMapi -AllowBasicAuthOfflineAddressBook -AllowBasicAuthOutlookService -AllowBasicAuthPop -AllowBasicAuthPowershell -AllowBasicAuthReportingWebServices -AllowBasicAuthRpc -AllowBasicAuthSmtp -AllowBasicAuthWebServices Basic auth enabled for all protocols. Executing the Python script. Could retrieve all the messages from the mailbox. Disabling the basic auth for all protocols : Set-AuthenticationPolicy -Identity 'Block Legacy Auth for all protocols' -AllowBasicAuthAutodiscover:$false -AllowBasicAuthActiveSync:$false -AllowBasicAuthImap:$false -AllowBasicAuthMapi:$false -AllowBasicAuthOfflineAddressBook:$false -AllowBasicAuthOutlookService:$false -AllowBasicAuthPop:$false -AllowBasicAuthPowershell:$false -AllowBasicAuthReportingWebServices:$false -AllowBasicAuthRpc:$false -AllowBasicAuthSmtp:$false -AllowBasicAuthWebServices:$false Basic auth disabled for all protocols. The test will fail with below error : exchangelib.errors.AutoDiscoverFailed: All steps in the autodiscover protocol failed for email 'email'. If you think this is an error, consider doing an official test at https://testconnectivity.microsoft.com Below is the complete output : MalformedResponseError: Unknown failure in response. Code: 456 headers: {'Server': 'Microsoft-IIS/10.0', 'request-id': 'a0b4fc1a-bb88-f79b-c6c4-3cc943faee4d', 'Alt-Svc': 'h3=\":443\",h3-29=\":443\"', 'X-CalculatedBETarget': 'DM6PR03MB4922.namprd03.PROD.OUTLOOK.COM', 'X-BackEndHttpStatus': '456', 'X-RUM-Validated': '1', 'X-AutoDiscovery-Error': 'LiveIdBasicAuth:AppPasswordRequired: PII.Email:b9Rjt8lxR2vyOYmKJLf+KhYvvk1IckE5k8vkcu1ptTg=@redteamsimulation.com > ><HitHrd <oAuth:,<V2;', 'X-DiagInfo': 'DM6PR03MB4922', 'X-BEServer': 'DM6PR03MB4922', 'X-Proxy-RoutingCorrectness': '1', 'X-Proxy-BackendServerStatus': '456', 'X-FirstHopCafeEFZ': 'LYH', 'X-FEProxyInfo': 'BN7PR06CA0046.NAMPRD06.PROD.OUTLOOK.COM', 'X-FEEFZInfo': 'LYH', 'X-Powered-By': 'ASP.NET', 'X-FEServer': 'BN7PR06CA0046', 'Date': 'Mon, 16 May 2022 04:05:02 GMT', 'Content-Length': '0'} content: Retry: 0 Waited: 10 Timeout: 10 Session: 24641 Thread: 24360 Auth type: URL: https://autodiscover-s.outlook.com/Autodiscover/Autodiscover.xml HTTP adapter: Allow redirects: False Streaming: False Response time: 0.32800000000861473 Status code: 456 Request headers: {'User-Agent': 'exchangelib/4.5.2 (python-requests/2.26.0)', 'Accept-Encoding': 'gzip, deflate', 'Accept': ' / ', 'Connection': 'keep-alive', 'Content-Type': 'text/xml; charset=utf-8', 'Content-Length': '367', 'Authorization': 'Basic ZG9uYWxkYmxha2VAcmVkdGVhbXNpbXVsYXRpb24uY29tOjhxa1FWSmFwVG8ldXdRdio5Xkw4eUxMI1Y5T3hKYQ=='} Response headers: {'Server': 'Microsoft-IIS/10.0', 'request-id': 'a0b4fc1a-bb88-f79b-c6c4-3cc943faee4d', 'Alt-Svc': 'h3=\":443\",h3-29=\":443\"', 'X-CalculatedBETarget': 'DM6PR03MB4922.namprd03.PROD.OUTLOOK.COM', 'X-BackEndHttpStatus': '456', 'X-RUM-Validated': '1', 'X-AutoDiscovery-Error': 'LiveIdBasicAuth:AppPasswordRequired: PII.Email:b9Rjt8lxR2vyOYmKJLf+KhYvvk1IckE5k8vkcu1ptTg=@redteamsimulation.com > ><HitHrd <oAuth:,<V2;', 'X-DiagInfo': 'DM6PR03MB4922', 'X-BEServer': 'DM6PR03MB4922', 'X-Proxy-RoutingCorrectness': '1', 'X-Proxy-BackendServerStatus': '456', 'X-FirstHopCafeEFZ': 'LYH', 'X-FEProxyInfo': 'BN7PR06CA0046.NAMPRD06.PROD.OUTLOOK.COM', 'X-FEEFZInfo': 'LYH', 'X-Powered-By': 'ASP.NET', 'X-FEServer': 'BN7PR06CA0046', 'Date': 'Mon, 16 May 2022 04:05:02 GMT', 'Content-Length': '0'} Request XML: b'<?xml version=\\'1.0\\' encoding=\\'utf-8\\'?>\\n donaldblake@redteamsimulation.com http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a ' Response XML: b'' Traceback (most recent call last): File \"C:\\ashish\\code\\repos\\pyAbuseEWS\\pyAbuseEWS.py\", line 43, in account = Account(username, credentials=credentials, autodiscover=True) File \"C:\\Python310\\lib\\site-packages\\exchangelib\\account.py\", line 118, in init self.ad_response, self.protocol = discover( File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 27, in discover ).discover() File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 122, in discover ad_response = self._step_1(hostname=domain) File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 427, in _step_1 return self._step_2(hostname=hostname) File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 443, in _step_2 return self._step_3(hostname=hostname) File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 473, in _step_3 return self._step_4(hostname=hostname) File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 502, in _step_4 return self._step_6() File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 553, in _step_6 raise AutoDiscoverFailed( exchangelib.errors.AutoDiscoverFailed: All steps in the autodiscover protocol failed for email 'donaldblake@redteamsimulation.com'. If you think this is an error, consider doing an official test at https://testconnectivity.microsoft.com \ue0b0 ashish@jarvis","title":"Disable basic authentication"},{"location":"DisableBasicAuth/#what-is-basic-authentication","text":"","title":"What is Basic Authentication?"},{"location":"DisableBasicAuth/#tests","text":"","title":"Tests"},{"location":"DisableBasicAuth/#the-python-script","text":"In order to test the basic authentication, we will make use of the below script which tries to authenticate to Exchange Online with a given set of users using Exchange Web Services (EWS). EWS uses Autodiscover protocol which in turn could use basic authentication. from exchangelib import Credentials, Account import requests import os from pathlib import Path import re external_ip = requests.get('https://ident.me').text print(external_ip) current_dir = os.getcwd() creds_file = os.path.join(current_dir, \"creds.txt\") if not os.path.isfile(creds_file): fp = open('creds_file', 'x') fp.close() print(\"Credentials file did not exist. We created a new one. Please populate with username and password separated by || in each line\") quit() with open(creds_file) as f: lines = f.readlines() for line in lines: line = line.rstrip() cred = line.split(\"||\") username = cred[0] password = cred[1] print(username) print(password) credentials = Credentials(username, password) account = Account(username, credentials=credentials, autodiscover=True) user_folder= current_dir+\"/\"+username Path(user_folder).mkdir(parents=True, exist_ok=True) for msg in account.inbox.all().order_by('-datetime_received')[:10]: email_content=\"\" clean_subject = re.sub('[^A-Za-z0-9]+','', msg.subject ) msg_folder_to_save = user_folder +\"/\"+clean_subject msg_contents_file = msg_folder_to_save +\"/msg.txt\" Path(msg_folder_to_save).mkdir(parents=True, exist_ok=True) #print(msg.subject, msg.sender, msg.datetime_received) email_content += \"sender ={}\".format(msg.sender) + \"\\n\" email_content += \"datetime_sent ={}\".format(msg.datetime_sent)+ \"\\n\" email_content += \"subject ={}\".format(msg.subject)+ \"\\n\" email_content += \"text_body ={}\".format(msg.text_body.encode('UTF-8'))+ \"\\n\" with open(msg_contents_file, \"w+\") as f: f.write(email_content) print(email_content) print(\"#\" * 80) for attachment in msg.attachments: fpath = os.path.join(msg_folder_to_save, attachment.name) with open(fpath, 'wb') as f: f.write(attachment.content)","title":"The Python Script"},{"location":"DisableBasicAuth/#enabling-the-basic-auth-for-all-protocols","text":"Set-AuthenticationPolicy -Identity 'Block Legacy Auth for all protocols' -AllowBasicAuthAutodiscover -AllowBasicAuthActiveSync -AllowBasicAuthImap -AllowBasicAuthMapi -AllowBasicAuthOfflineAddressBook -AllowBasicAuthOutlookService -AllowBasicAuthPop -AllowBasicAuthPowershell -AllowBasicAuthReportingWebServices -AllowBasicAuthRpc -AllowBasicAuthSmtp -AllowBasicAuthWebServices Basic auth enabled for all protocols. Executing the Python script. Could retrieve all the messages from the mailbox.","title":"Enabling the basic auth for all protocols : "},{"location":"DisableBasicAuth/#disabling-the-basic-auth-for-all-protocols","text":"Set-AuthenticationPolicy -Identity 'Block Legacy Auth for all protocols' -AllowBasicAuthAutodiscover:$false -AllowBasicAuthActiveSync:$false -AllowBasicAuthImap:$false -AllowBasicAuthMapi:$false -AllowBasicAuthOfflineAddressBook:$false -AllowBasicAuthOutlookService:$false -AllowBasicAuthPop:$false -AllowBasicAuthPowershell:$false -AllowBasicAuthReportingWebServices:$false -AllowBasicAuthRpc:$false -AllowBasicAuthSmtp:$false -AllowBasicAuthWebServices:$false Basic auth disabled for all protocols. The test will fail with below error : exchangelib.errors.AutoDiscoverFailed: All steps in the autodiscover protocol failed for email 'email'. If you think this is an error, consider doing an official test at https://testconnectivity.microsoft.com Below is the complete output : MalformedResponseError: Unknown failure in response. Code: 456 headers: {'Server': 'Microsoft-IIS/10.0', 'request-id': 'a0b4fc1a-bb88-f79b-c6c4-3cc943faee4d', 'Alt-Svc': 'h3=\":443\",h3-29=\":443\"', 'X-CalculatedBETarget': 'DM6PR03MB4922.namprd03.PROD.OUTLOOK.COM', 'X-BackEndHttpStatus': '456', 'X-RUM-Validated': '1', 'X-AutoDiscovery-Error': 'LiveIdBasicAuth:AppPasswordRequired: PII.Email:b9Rjt8lxR2vyOYmKJLf+KhYvvk1IckE5k8vkcu1ptTg=@redteamsimulation.com > ><HitHrd <oAuth:,<V2;', 'X-DiagInfo': 'DM6PR03MB4922', 'X-BEServer': 'DM6PR03MB4922', 'X-Proxy-RoutingCorrectness': '1', 'X-Proxy-BackendServerStatus': '456', 'X-FirstHopCafeEFZ': 'LYH', 'X-FEProxyInfo': 'BN7PR06CA0046.NAMPRD06.PROD.OUTLOOK.COM', 'X-FEEFZInfo': 'LYH', 'X-Powered-By': 'ASP.NET', 'X-FEServer': 'BN7PR06CA0046', 'Date': 'Mon, 16 May 2022 04:05:02 GMT', 'Content-Length': '0'} content: Retry: 0 Waited: 10 Timeout: 10 Session: 24641 Thread: 24360 Auth type: URL: https://autodiscover-s.outlook.com/Autodiscover/Autodiscover.xml HTTP adapter: Allow redirects: False Streaming: False Response time: 0.32800000000861473 Status code: 456 Request headers: {'User-Agent': 'exchangelib/4.5.2 (python-requests/2.26.0)', 'Accept-Encoding': 'gzip, deflate', 'Accept': ' / ', 'Connection': 'keep-alive', 'Content-Type': 'text/xml; charset=utf-8', 'Content-Length': '367', 'Authorization': 'Basic ZG9uYWxkYmxha2VAcmVkdGVhbXNpbXVsYXRpb24uY29tOjhxa1FWSmFwVG8ldXdRdio5Xkw4eUxMI1Y5T3hKYQ=='} Response headers: {'Server': 'Microsoft-IIS/10.0', 'request-id': 'a0b4fc1a-bb88-f79b-c6c4-3cc943faee4d', 'Alt-Svc': 'h3=\":443\",h3-29=\":443\"', 'X-CalculatedBETarget': 'DM6PR03MB4922.namprd03.PROD.OUTLOOK.COM', 'X-BackEndHttpStatus': '456', 'X-RUM-Validated': '1', 'X-AutoDiscovery-Error': 'LiveIdBasicAuth:AppPasswordRequired: PII.Email:b9Rjt8lxR2vyOYmKJLf+KhYvvk1IckE5k8vkcu1ptTg=@redteamsimulation.com > ><HitHrd <oAuth:,<V2;', 'X-DiagInfo': 'DM6PR03MB4922', 'X-BEServer': 'DM6PR03MB4922', 'X-Proxy-RoutingCorrectness': '1', 'X-Proxy-BackendServerStatus': '456', 'X-FirstHopCafeEFZ': 'LYH', 'X-FEProxyInfo': 'BN7PR06CA0046.NAMPRD06.PROD.OUTLOOK.COM', 'X-FEEFZInfo': 'LYH', 'X-Powered-By': 'ASP.NET', 'X-FEServer': 'BN7PR06CA0046', 'Date': 'Mon, 16 May 2022 04:05:02 GMT', 'Content-Length': '0'} Request XML: b'<?xml version=\\'1.0\\' encoding=\\'utf-8\\'?>\\n donaldblake@redteamsimulation.com http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a ' Response XML: b'' Traceback (most recent call last): File \"C:\\ashish\\code\\repos\\pyAbuseEWS\\pyAbuseEWS.py\", line 43, in account = Account(username, credentials=credentials, autodiscover=True) File \"C:\\Python310\\lib\\site-packages\\exchangelib\\account.py\", line 118, in init self.ad_response, self.protocol = discover( File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 27, in discover ).discover() File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 122, in discover ad_response = self._step_1(hostname=domain) File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 427, in _step_1 return self._step_2(hostname=hostname) File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 443, in _step_2 return self._step_3(hostname=hostname) File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 473, in _step_3 return self._step_4(hostname=hostname) File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 502, in _step_4 return self._step_6() File \"C:\\Python310\\lib\\site-packages\\exchangelib\\autodiscover\\discovery.py\", line 553, in _step_6 raise AutoDiscoverFailed( exchangelib.errors.AutoDiscoverFailed: All steps in the autodiscover protocol failed for email 'donaldblake@redteamsimulation.com'. If you think this is an error, consider doing an official test at https://testconnectivity.microsoft.com \ue0b0 ashish@jarvis","title":"Disabling the basic auth for all protocols : "},{"location":"DisableSMTPAuth/","text":"Tests Below code tries to use Basic Auth over SMTP Auth protocol and fails becuase SMTP Auth is disabled $creds = get-credential Send-MailMessage \u2013From donaldblake@redteamsimulation.com \u2013To ashishxxx@xxx.com \u2013Subject \"Test Email\" \u2013Body \"Test SMTP Service from Powershell\" -SmtpServer smtp.office365.com -Credential $creds -UseSsl -Port 587 Error Message : Send-MailMessage : The SMTP server requires a secure connection or the client was not authenticated. The server response was: 5.7.57 Client not authenticated to send mail. Error: 535 5.7.139 Authentication unsuccessful, SmtpClientAuthentication is disabled for the Tenant. Visit https://aka.ms/smtp_auth_disabled for more information. [BN0PR10CA0026.namprd10.prod.outlook.com] At line:1 char:1 + Send-MailMessage \u2013From donaldblake@redteamsimulation.com \u2013To ashishmg ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidOperation: (System.Net.Mail.SmtpClient:SmtpClient) [Send-MailMessage], SmtpExcept ion + FullyQualifiedErrorId : SmtpException,Microsoft.PowerShell.Commands.SendMailMessage","title":"Disable SMTP Auth"},{"location":"DisableSMTPAuth/#tests","text":"Below code tries to use Basic Auth over SMTP Auth protocol and fails becuase SMTP Auth is disabled $creds = get-credential Send-MailMessage \u2013From donaldblake@redteamsimulation.com \u2013To ashishxxx@xxx.com \u2013Subject \"Test Email\" \u2013Body \"Test SMTP Service from Powershell\" -SmtpServer smtp.office365.com -Credential $creds -UseSsl -Port 587 Error Message : Send-MailMessage : The SMTP server requires a secure connection or the client was not authenticated. The server response was: 5.7.57 Client not authenticated to send mail. Error: 535 5.7.139 Authentication unsuccessful, SmtpClientAuthentication is disabled for the Tenant. Visit https://aka.ms/smtp_auth_disabled for more information. [BN0PR10CA0026.namprd10.prod.outlook.com] At line:1 char:1 + Send-MailMessage \u2013From donaldblake@redteamsimulation.com \u2013To ashishmg ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidOperation: (System.Net.Mail.SmtpClient:SmtpClient) [Send-MailMessage], SmtpExcept ion + FullyQualifiedErrorId : SmtpException,Microsoft.PowerShell.Commands.SendMailMessage","title":"Tests"},{"location":"EnableSelfServicePasswordReset/","text":"","title":"Enable Self Service Password Reset"},{"location":"ImplementMFA/","text":"PowerShell to create a conditional Acesss Policy to enforce all MFA on all users excluding an emergency Azure cloud-only Account. $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } $CurrentlyLoggedInUser $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId $EmergencyUserUPNPrefix = \"EmUser\" $UserDisplayName = \"EmergencyUser\" $TenantDomain = $Connection.TenantDomain $OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@')) $OnMicrosoftDomain $UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain $EmUser = $NULL try{ $EmUser = Get-AzureADUser -ObjectId $UserPrincipalName -ErrorAction silentlycontinue write-output(\"Emergency user \" + $UserPrincipalName + ' already exists.') }catch{ write-output(\"Emergency user \" + $UserPrincipalName + ' does not exist. Creating now..') Add-Type -AssemblyName System.Web $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2) $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile $PasswordProfile.Password = $UserPassword $UserPassword $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\" # Adding the new user to Global Admin role Write-output \"Adding the new user to Global Admin r+ole\" $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq \"Global Administrator\"} Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"Username: \" + $UserPrincipalName) Add-Content $temp_file (\"Password: \" + $UserPassword) .\\notepad.exe $temp_file write-output(\"User details written to the file\\r\\n\") } $conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet $conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition $conditions.Applications.IncludeApplications = \"all\" $conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition $conditions.Users.IncludeUsers = \"all\" $conditions.Users.ExcludeUsers = $EmUser.ObjectId $controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls $controls._Operator = \"OR\" $controls.BuiltInControls = \"mfa\" New-AzureADMSConditionalAccessPolicy -DisplayName \"Enforce MFA on all users\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls Write-Output \"Conditional Access policy created\" Conditional Access policy is created. MFA is enforced for all apps. MFA is enforced for all users except the emergency global admin user.","title":"Implement MFA"},{"location":"RestrictExtarnelCollaboration/","text":"","title":"Restrict Extarnel Collaboration"},{"location":"SMTPAuthTests/","text":"# Sender Credentials # Sender and Recipient Info $MailFrom = \"ashish.gupta@lplfinancial.com\" $MailTo = \"ashishmgupta@hotmail.com\" $Username = \"infosec.test@lplfinancial.com\" $Password = \"bN1A&Fwf018s8huq%Aff\" # Server Info $SmtpServer = \"smtp.office365.com\" $SmtpPort = \"587\" # Message stuff $MessageSubject = \"Microsoft .NET documentation\" $Message = New-Object System.Net.Mail.MailMessage $MailFrom,$MailTo $Message.IsBodyHTML = $true $Message.Subject = $MessageSubject $Message.Body = @' <!DOCTYPE html> <html> <head> </head> <body> https://docs.microsoft.com </body> </html> '@ # Construct the SMTP client object, credentials, and send $Smtp = New-Object Net.Mail.SmtpClient($SmtpServer,$SmtpPort) $Smtp.EnableSsl = $true $Smtp.Credentials = New-Object System.Net.NetworkCredential($Username,$Password) $Smtp.Send($Message)","title":"SMTPAuthTests"},{"location":"SetupAzureADAppForSplunk/","text":"This section covers setting up an Azure AD app for Splunk Add-on so O365 logs could be ingested in Splunk. Below script would create the app so It does not need to be created manually. The admin consent needs to be granted via the Azure portal (instructions below). The details for the newly created app needs to be provided to the Splunk Administrator so they could set up the Azure tenant for the log ingestion. Step 0 - Install Azure AD Powershell Please execute the below in PowerShell to install the Azure AD module for Powershell Install-Module AzureAD Please ensure you are executing the above in Powershell v5.1 and not 7.x. Execute the below to ensure : $PSVersionTable Step 1 - PowerShell script to Create the app Please ensure you are in the Global Administrator role in the tenant. The script may prompt you to login. Open Powershell as administrator. Copy the script by clicking on the copy icon in script below. Paste the script on the Powershell window and hit enter. # Author - Ashish Gupta # This script creates a new Azure AD application and sets the Application and Delegated permissions for specific API (O365) $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } $CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\") $ApplicationDisplayName = \"Splunk App for Office 365\" $AzureADAppForSplunk = Get-AzureADApplication -Filter \"DisplayName eq '$ApplicationDisplayName'\" if($AzureADAppForSplunk -eq $NULL) { write-output(\"AzureAD application \" + $ApplicationDisplayName + \" does not exist. Creating...\") # Get the service principal for O365 and Microsoft Graph $ServicePrincipalO365API = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Office 365 Management APIs\" } $ServicePrincipalMicrosoftGraph = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Microsoft Graph\" } # Get all application permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphAppRoles = $ServicePrincipalMicrosoftGraph.AppRoles | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all delegated permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphDelegatedRoles = $ServicePrincipalMicrosoftGraph.Oauth2Permissions | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all application permissions for O365 API $ServicePrincipalO365APIAppRoles = $ServicePrincipalO365API.AppRoles | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Get all delegated permissions for O365 API $ServicePrincipalO365APIDelegatedRoles = $ServicePrincipalO365API.Oauth2Permissions | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Create a Required Resource Access object for Office 365 $RequiredResourceAccessO365API = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessO365API.ResourceAppId = $ServicePrincipalO365API.AppId # Create a Required Resource Access object for Microsoft Graph $RequiredResourceAccessMicrosoftGraph = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessMicrosoftGraph.ResourceAppId = $ServicePrincipalMicrosoftGraph.AppId $ServicePrincipalO365APIAppRolesSelectedPermissions = @() $ServicePrincipalSelectedPermissionsMicrosoftGraph = @() # Get all the Resource Access objects for the Application permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Application permissions for Office 365 API\" foreach ($ServicePrincipalO365APIAppRole in $ServicePrincipalO365APIAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIAppRole.Id,\"Role\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Delegated permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Delegated permissions for Office 365 API\" foreach ($ServicePrincipalO365APIDelegatedRole in $ServicePrincipalO365APIDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIDelegatedRole.Id,\"Scope\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Application permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Application permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphAppRole in $ServicePrincipalMicrosoftGraphAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphAppRole.Id,\"Role\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphDelegatedRole in $ServicePrincipalMicrosoftGraphDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphDelegatedRole.Id,\"Scope\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Assign all the permissions to the required Resource access for the O365 API $RequiredResourceAccessO365API.ResourceAccess = $ServicePrincipalO365APIAppRolesSelectedPermissions # Assign all the permissions to the required Resource access for the Microsoft Graph $RequiredResourceAccessMicrosoftGraph.ResourceAccess = $ServicePrincipalSelectedPermissionsMicrosoftGraph # Create the Password credential for the new app Add-Type -AssemblyName System.Web $ApplicationPassword =[System.Web.Security.Membership]::GeneratePassword(32,2) $ApplicationPassword = $ApplicationPassword.Replace(\"+\",\"_\") $ApplicationPassword = $ApplicationPassword.Replace(\"-\",\"_\") $keyId = (New-Guid).ToString(); $fromDate = [System.DateTime]::Now $durationInYears = 5 $endDate = $fromDate.AddYears($durationInYears) $Applicationkey = New-Object Microsoft.Open.AzureAD.Model.PasswordCredential($null, $endDate, $keyId, $fromDate, $ApplicationPassword) # Create the new app with the password cred $aadApplication = New-AzureADApplication -DisplayName $ApplicationDisplayName -PasswordCredentials $Applicationkey write-output(\"Application created\") # Set the permissions Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $RequiredResourceAccessO365API,$RequiredResourceAccessMicrosoftGraph write-output(\"Application permissions set\") # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Azure AD App display name: \" + $aadApplication.DisplayName) Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"App ClientId: \" + $aadApplication.AppId) Add-Content $temp_file (\"App Password: \" + $ApplicationPassword) .\\notepad.exe $temp_file write-output(\"Application details written to the file\") }else{ write-output(\"AzureAD application '\" + $AzureADAppForSplunk.DisplayName + \"' already exists.\") } The powershell script got executed and we can see the newly created app in the Azure portal: Step 2 - Provide app details to Splunk Admin The details for the newly created app is opened in the Notepad. This should be sent to the Splunk Administrator so they could set up the Splunk Add-on for O365 for this tenant. Step 3 - Grant Admin Consent in Azure Portal Log in to the Azure portal as Global Administrator. Navigate to Azure Active Directory > App Registrations > Click on \"All Applications\" > Go to \"Splunk app for Office 365\". In the app, click on \"API Permissions\". Notice all the permissions have already been assigned via the script. Click on \"Grant admin consent for tenant\" After the admin consent grant, It should look like below :","title":"Setup AzureAD App For Splunk"},{"location":"SetupAzureADAppForSplunk/#step-0-install-azure-ad-powershell","text":"Please execute the below in PowerShell to install the Azure AD module for Powershell Install-Module AzureAD Please ensure you are executing the above in Powershell v5.1 and not 7.x. Execute the below to ensure : $PSVersionTable","title":"Step 0 - Install Azure AD Powershell"},{"location":"SetupAzureADAppForSplunk/#step-1-powershell-script-to-create-the-app","text":"Please ensure you are in the Global Administrator role in the tenant. The script may prompt you to login. Open Powershell as administrator. Copy the script by clicking on the copy icon in script below. Paste the script on the Powershell window and hit enter. # Author - Ashish Gupta # This script creates a new Azure AD application and sets the Application and Delegated permissions for specific API (O365) $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } $CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\") $ApplicationDisplayName = \"Splunk App for Office 365\" $AzureADAppForSplunk = Get-AzureADApplication -Filter \"DisplayName eq '$ApplicationDisplayName'\" if($AzureADAppForSplunk -eq $NULL) { write-output(\"AzureAD application \" + $ApplicationDisplayName + \" does not exist. Creating...\") # Get the service principal for O365 and Microsoft Graph $ServicePrincipalO365API = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Office 365 Management APIs\" } $ServicePrincipalMicrosoftGraph = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Microsoft Graph\" } # Get all application permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphAppRoles = $ServicePrincipalMicrosoftGraph.AppRoles | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all delegated permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphDelegatedRoles = $ServicePrincipalMicrosoftGraph.Oauth2Permissions | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all application permissions for O365 API $ServicePrincipalO365APIAppRoles = $ServicePrincipalO365API.AppRoles | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Get all delegated permissions for O365 API $ServicePrincipalO365APIDelegatedRoles = $ServicePrincipalO365API.Oauth2Permissions | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Create a Required Resource Access object for Office 365 $RequiredResourceAccessO365API = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessO365API.ResourceAppId = $ServicePrincipalO365API.AppId # Create a Required Resource Access object for Microsoft Graph $RequiredResourceAccessMicrosoftGraph = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessMicrosoftGraph.ResourceAppId = $ServicePrincipalMicrosoftGraph.AppId $ServicePrincipalO365APIAppRolesSelectedPermissions = @() $ServicePrincipalSelectedPermissionsMicrosoftGraph = @() # Get all the Resource Access objects for the Application permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Application permissions for Office 365 API\" foreach ($ServicePrincipalO365APIAppRole in $ServicePrincipalO365APIAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIAppRole.Id,\"Role\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Delegated permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Delegated permissions for Office 365 API\" foreach ($ServicePrincipalO365APIDelegatedRole in $ServicePrincipalO365APIDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIDelegatedRole.Id,\"Scope\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Application permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Application permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphAppRole in $ServicePrincipalMicrosoftGraphAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphAppRole.Id,\"Role\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphDelegatedRole in $ServicePrincipalMicrosoftGraphDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphDelegatedRole.Id,\"Scope\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Assign all the permissions to the required Resource access for the O365 API $RequiredResourceAccessO365API.ResourceAccess = $ServicePrincipalO365APIAppRolesSelectedPermissions # Assign all the permissions to the required Resource access for the Microsoft Graph $RequiredResourceAccessMicrosoftGraph.ResourceAccess = $ServicePrincipalSelectedPermissionsMicrosoftGraph # Create the Password credential for the new app Add-Type -AssemblyName System.Web $ApplicationPassword =[System.Web.Security.Membership]::GeneratePassword(32,2) $ApplicationPassword = $ApplicationPassword.Replace(\"+\",\"_\") $ApplicationPassword = $ApplicationPassword.Replace(\"-\",\"_\") $keyId = (New-Guid).ToString(); $fromDate = [System.DateTime]::Now $durationInYears = 5 $endDate = $fromDate.AddYears($durationInYears) $Applicationkey = New-Object Microsoft.Open.AzureAD.Model.PasswordCredential($null, $endDate, $keyId, $fromDate, $ApplicationPassword) # Create the new app with the password cred $aadApplication = New-AzureADApplication -DisplayName $ApplicationDisplayName -PasswordCredentials $Applicationkey write-output(\"Application created\") # Set the permissions Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $RequiredResourceAccessO365API,$RequiredResourceAccessMicrosoftGraph write-output(\"Application permissions set\") # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Azure AD App display name: \" + $aadApplication.DisplayName) Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"App ClientId: \" + $aadApplication.AppId) Add-Content $temp_file (\"App Password: \" + $ApplicationPassword) .\\notepad.exe $temp_file write-output(\"Application details written to the file\") }else{ write-output(\"AzureAD application '\" + $AzureADAppForSplunk.DisplayName + \"' already exists.\") } The powershell script got executed and we can see the newly created app in the Azure portal:","title":"Step 1 - PowerShell script to Create the app"},{"location":"SetupAzureADAppForSplunk/#step-2-provide-app-details-to-splunk-admin","text":"The details for the newly created app is opened in the Notepad. This should be sent to the Splunk Administrator so they could set up the Splunk Add-on for O365 for this tenant.","title":"Step 2 - Provide app details to Splunk Admin"},{"location":"SetupAzureADAppForSplunk/#step-3-grant-admin-consent-in-azure-portal","text":"Log in to the Azure portal as Global Administrator. Navigate to Azure Active Directory > App Registrations > Click on \"All Applications\" > Go to \"Splunk app for Office 365\". In the app, click on \"API Permissions\". Notice all the permissions have already been assigned via the script. Click on \"Grant admin consent for tenant\" After the admin consent grant, It should look like below :","title":"Step 3 - Grant Admin Consent in Azure Portal"}]}