{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Overview"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"BlockOFACCountries/","text":"We create named location which has the list of countries we need to block all requests from. Then we create a conditional access policy to use that list to implement the block. ALL users would be blocked from OFAC countries except the currently logged in user. A user website to look for ISO codes (among others) for countries is https://countrycode.org The PowerShell script: # Connect to AzureAD and get current logged in user $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connect now...\"; Write-Host \"You're not connected to AzureAD\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } $NamedLocationPolicyName = \"OFAC Countries\" $NamedLocationPolicy = Get-AzureADMSNamedLocationPolicy | Where-Object {$_.DisplayName -eq $NamedLocationPolicy} if ($NamedLocationPolicy -eq $null) { # Create a named location policy which includes all the OFAC Countries. $NamedLocationPolicy = New-AzureADMSNamedLocationPolicy -OdataType \"#microsoft.graph.countryNamedLocation\" -DisplayName $NamedLocationPolicyName -CountriesAndRegions \"BY\",\"BI\",\"BA\",\"CD\",\"CF\",\"CI\",\"CN\",\"CU\",\"IQ\",\"IR\",\"KP\",\"LR\",\"MD\",\"ME\",\"MK\",\"NI\",\"RU\",\"RS\",\"SD\",\"SS\",\"SY\",\"UA\",\"VE\",\"YE\",\"ZW\",\"AU\" -IncludeUnknownCountriesAndRegions $false Write-Host \"Named location policy : \" + $NamedLocationPolicyName + \" has been created.\" Write-Host \"Countries included : \" + $NamedLocationPolicyName.CountriesAndRegions }else{ Write-Host \"Named location policy : \" + $NamedLocationPolicyName + \" already exists.\" Write-Host \"Countries included : \" + $NamedLocationPolicyName.CountriesAndRegions } # Create the conditional access policy to block access from all OFAC countries to all apps for all users except the currently logged in user $conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet $conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition $conditions.Applications.IncludeApplications = \"all\" $conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition $conditions.Users.IncludeUsers = \"all\" $conditions.Users.ExcludeUsers = $CurrentUserId $conditions.Locations = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessLocationCondition $conditions.Locations.IncludeLocations = $NamedLocationPolicy.Id $controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls $controls._Operator = \"OR\" $controls.BuiltInControls = \"block\" New-AzureADMSConditionalAccessPolicy -DisplayName \"Block OFAC countries\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls The conditional access policy is created. The conditional access policy showing block condition for the location noted in the named location \"OFAC Countries\".","title":"Block OFAC Countries"},{"location":"CreateEmergencyUser/","text":"We protect our users by enforcing Azure MFA. However, Azure MFA has gone down before and we dont want administrators to be locked out of tennat to troubleshoot if this happens again. So, this account will be assigned a Global Admin role and wont have the MFA enforced on it. Given high privileges on this account, any attempt of usage this emergency login should generate a high alert for Security Opertion Center to validate the legit use. The PowerShell script to create the user and : $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } $CurrentlyLoggedInUser $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId $EmergencyUserUPNPrefix = \"EmUser\" $UserDisplayName = \"EmergencyUser\" $TenantDomain = $Connection.TenantDomain $OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@')) $OnMicrosoftDomain $UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain $EmUser = $NULL try{ $EmUser = Get-AzureADUser -ObjectId $UserPrincipalName -ErrorAction silentlycontinue write-output(\"Emergency user \" + $UserPrincipalName + ' already exists.') }catch{ write-output(\"Emergency user \" + $UserPrincipalName + ' does not exist. Creating now..') Add-Type -AssemblyName System.Web $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2) $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile $PasswordProfile.Password = $UserPassword $UserPassword $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\" # Adding the new user to Global Admin role Write-output \"Adding the new user to Global Admin r+ole\" $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq \"Global Administrator\"} Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"Username: \" + $UserPrincipalName) Add-Content $temp_file (\"Password: \" + $UserPassword) .\\notepad.exe $temp_file write-output(\"User details written to the file\\r\\n\") } The emergency user is created. The emergency user is assigned the Global Administrator role on permanent basis.","title":"Create Emergency User"},{"location":"DisableBasicAuth/","text":"Disable Basic Authentication We create an authentication policy which has by default basic auth disabled for all protocols. And the set the default authentication policy for the whole organization the newly created authentication policy New-AuthenticationPolicy \"Disable all BasicAuth\" Set-OrganizationConfig -DefaultAuthenticationPolicy \"Disable all BasicAuth\" Check the newly created authentication policy : The default authentication policy is set to the newly created authentication policy. Get-OrganizationConfig | select DefaultAuthenticationPolicy We can also check the Microsoft Admin Center. Go to Microsoft 365 Admin Center Settings > Org Settings > Modern Authentication All the settings except the \"Turn on modern authentication for Outlook 2013 for Windows and later (recommended)\" should be unchecked.","title":"Disable basic authentication"},{"location":"EnableSelfServicePasswordReset/","text":"","title":"Enable Self Service Password Reset"},{"location":"ImplementMFA/","text":"PowerShell to create a conditional Acesss Policy to enforce all MFA on all users excluding an emergency Azure cloud-only Account. $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" } $CurrentlyLoggedInUser $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId $EmergencyUserUPNPrefix = \"EmUser\" $UserDisplayName = \"EmergencyUser\" $TenantDomain = $Connection.TenantDomain $OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@')) $OnMicrosoftDomain $UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain $EmUser = $NULL try{ $EmUser = Get-AzureADUser -ObjectId $UserPrincipalName -ErrorAction silentlycontinue write-output(\"Emergency user \" + $UserPrincipalName + ' already exists.') }catch{ write-output(\"Emergency user \" + $UserPrincipalName + ' does not exist. Creating now..') Add-Type -AssemblyName System.Web $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2) $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile $PasswordProfile.Password = $UserPassword $UserPassword $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\" # Adding the new user to Global Admin role Write-output \"Adding the new user to Global Admin r+ole\" $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq \"Global Administrator\"} Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"Username: \" + $UserPrincipalName) Add-Content $temp_file (\"Password: \" + $UserPassword) .\\notepad.exe $temp_file write-output(\"User details written to the file\\r\\n\") } $conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet $conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition $conditions.Applications.IncludeApplications = \"all\" $conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition $conditions.Users.IncludeUsers = \"all\" $conditions.Users.ExcludeUsers = $EmUser.ObjectId $controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls $controls._Operator = \"OR\" $controls.BuiltInControls = \"mfa\" New-AzureADMSConditionalAccessPolicy -DisplayName \"Enforce MFA on all users\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls Write-Output \"Conditional Access policy created\" Conditional Access policy is created. MFA is enforced for all apps. MFA is enforced for all users except the emergency global admin user.","title":"Implement MFA"},{"location":"RestrictExtarnelCollaboration/","text":"","title":"Restrict Extarnel Collaboration"},{"location":"SetupAzureADAppForSplunk/","text":"This section covers setting up an Azure AD app for Splunk Add-on so O365 logs could be ingested in Splunk. Below script would create the app so It does not need to be created manually. The admin consent needs to be granted via the Azure portal (instructions below). The details for the newly created app needs to be provided to the Splunk Administrator so they could set up the Azure tenant for the log ingestion. Step 0 - Install Azure AD Powershell Please execute the below in PowerShell to install the Azure AD module for Powershell Install-Module AzureAD Please ensure you are executing the above in Powershell v5.1 and not 7.x. Execute the below to ensure : $PSVersionTable Step 1 - PowerShell script to Create the app Please ensure you are in the Global Administrator role in the tenant. The script may prompt you to login. Open Powershell as administrator. Copy the script by clicking on the copy icon in script below. Paste the script on the Powershell window and hit enter. # Author - Ashish Gupta # This script creates a new Azure AD application and sets the Application and Delegated permissions for specific API (O365) $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } $CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\") $ApplicationDisplayName = \"Splunk App for Office 365\" $AzureADAppForSplunk = Get-AzureADApplication -Filter \"DisplayName eq '$ApplicationDisplayName'\" if($AzureADAppForSplunk -eq $NULL) { write-output(\"AzureAD application \" + $ApplicationDisplayName + \" does not exist. Creating...\") # Get the service principal for O365 and Microsoft Graph $ServicePrincipalO365API = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Office 365 Management APIs\" } $ServicePrincipalMicrosoftGraph = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Microsoft Graph\" } # Get all application permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphAppRoles = $ServicePrincipalMicrosoftGraph.AppRoles | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all delegated permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphDelegatedRoles = $ServicePrincipalMicrosoftGraph.Oauth2Permissions | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all application permissions for O365 API $ServicePrincipalO365APIAppRoles = $ServicePrincipalO365API.AppRoles | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Get all delegated permissions for O365 API $ServicePrincipalO365APIDelegatedRoles = $ServicePrincipalO365API.Oauth2Permissions | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Create a Required Resource Access object for Office 365 $RequiredResourceAccessO365API = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessO365API.ResourceAppId = $ServicePrincipalO365API.AppId # Create a Required Resource Access object for Microsoft Graph $RequiredResourceAccessMicrosoftGraph = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessMicrosoftGraph.ResourceAppId = $ServicePrincipalMicrosoftGraph.AppId $ServicePrincipalO365APIAppRolesSelectedPermissions = @() $ServicePrincipalSelectedPermissionsMicrosoftGraph = @() # Get all the Resource Access objects for the Application permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Application permissions for Office 365 API\" foreach ($ServicePrincipalO365APIAppRole in $ServicePrincipalO365APIAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIAppRole.Id,\"Role\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Delegated permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Delegated permissions for Office 365 API\" foreach ($ServicePrincipalO365APIDelegatedRole in $ServicePrincipalO365APIDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIDelegatedRole.Id,\"Scope\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Application permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Application permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphAppRole in $ServicePrincipalMicrosoftGraphAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphAppRole.Id,\"Role\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphDelegatedRole in $ServicePrincipalMicrosoftGraphDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphDelegatedRole.Id,\"Scope\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Assign all the permissions to the required Resource access for the O365 API $RequiredResourceAccessO365API.ResourceAccess = $ServicePrincipalO365APIAppRolesSelectedPermissions # Assign all the permissions to the required Resource access for the Microsoft Graph $RequiredResourceAccessMicrosoftGraph.ResourceAccess = $ServicePrincipalSelectedPermissionsMicrosoftGraph # Create the Password credential for the new app Add-Type -AssemblyName System.Web $ApplicationPassword =[System.Web.Security.Membership]::GeneratePassword(32,2) $ApplicationPassword = $ApplicationPassword.Replace(\"+\",\"_\") $ApplicationPassword = $ApplicationPassword.Replace(\"-\",\"_\") $keyId = (New-Guid).ToString(); $fromDate = [System.DateTime]::Now $durationInYears = 5 $endDate = $fromDate.AddYears($durationInYears) $Applicationkey = New-Object Microsoft.Open.AzureAD.Model.PasswordCredential($null, $endDate, $keyId, $fromDate, $ApplicationPassword) # Create the new app with the password cred $aadApplication = New-AzureADApplication -DisplayName $ApplicationDisplayName -PasswordCredentials $Applicationkey write-output(\"Application created\") # Set the permissions Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $RequiredResourceAccessO365API,$RequiredResourceAccessMicrosoftGraph write-output(\"Application permissions set\") # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Azure AD App display name: \" + $aadApplication.DisplayName) Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"App ClientId: \" + $aadApplication.AppId) Add-Content $temp_file (\"App Password: \" + $ApplicationPassword) .\\notepad.exe $temp_file write-output(\"Application details written to the file\") }else{ write-output(\"AzureAD application '\" + $AzureADAppForSplunk.DisplayName + \"' already exists.\") } The powershell script got executed and we can see the newly created app in the Azure portal: Step 2 - Provide app details to Splunk Admin The details for the newly created app is opened in the Notepad. This should be sent to the Splunk Administrator so they could set up the Splunk Add-on for O365 for this tenant. Step 3 - Grant Admin Consent in Azure Portal Log in to the Azure portal as Global Administrator. Navigate to Azure Active Directory > App Registrations > Click on \"All Applications\" > Go to \"Splunk app for Office 365\". In the app, click on \"API Permissions\". Notice all the permissions have already been assigned via the script. Click on \"Grant admin consent for tenant\" After the admin consent grant, It should look like below :","title":"Setup AzureAD App For Splunk"},{"location":"SetupAzureADAppForSplunk/#step-0-install-azure-ad-powershell","text":"Please execute the below in PowerShell to install the Azure AD module for Powershell Install-Module AzureAD Please ensure you are executing the above in Powershell v5.1 and not 7.x. Execute the below to ensure : $PSVersionTable","title":"Step 0 - Install Azure AD Powershell"},{"location":"SetupAzureADAppForSplunk/#step-1-powershell-script-to-create-the-app","text":"Please ensure you are in the Global Administrator role in the tenant. The script may prompt you to login. Open Powershell as administrator. Copy the script by clicking on the copy icon in script below. Paste the script on the Powershell window and hit enter. # Author - Ashish Gupta # This script creates a new Azure AD application and sets the Application and Delegated permissions for specific API (O365) $TenantDetails = $NULL $CurrentlyLoggedInUser = $NULL $OnMicrosoftDomain = $NULL $connection = $NULL try { $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { Write-Host \"You're not connected to AzureAD. Connecting now...\"; $connection = Connect-AzureAD $AzureADSession = Get-AzureADCurrentSessionInfo $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\" $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId } $CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\") $ApplicationDisplayName = \"Splunk App for Office 365\" $AzureADAppForSplunk = Get-AzureADApplication -Filter \"DisplayName eq '$ApplicationDisplayName'\" if($AzureADAppForSplunk -eq $NULL) { write-output(\"AzureAD application \" + $ApplicationDisplayName + \" does not exist. Creating...\") # Get the service principal for O365 and Microsoft Graph $ServicePrincipalO365API = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Office 365 Management APIs\" } $ServicePrincipalMicrosoftGraph = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Microsoft Graph\" } # Get all application permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphAppRoles = $ServicePrincipalMicrosoftGraph.AppRoles | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all delegated permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphDelegatedRoles = $ServicePrincipalMicrosoftGraph.Oauth2Permissions | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all application permissions for O365 API $ServicePrincipalO365APIAppRoles = $ServicePrincipalO365API.AppRoles | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Get all delegated permissions for O365 API $ServicePrincipalO365APIDelegatedRoles = $ServicePrincipalO365API.Oauth2Permissions | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Create a Required Resource Access object for Office 365 $RequiredResourceAccessO365API = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessO365API.ResourceAppId = $ServicePrincipalO365API.AppId # Create a Required Resource Access object for Microsoft Graph $RequiredResourceAccessMicrosoftGraph = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessMicrosoftGraph.ResourceAppId = $ServicePrincipalMicrosoftGraph.AppId $ServicePrincipalO365APIAppRolesSelectedPermissions = @() $ServicePrincipalSelectedPermissionsMicrosoftGraph = @() # Get all the Resource Access objects for the Application permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Application permissions for Office 365 API\" foreach ($ServicePrincipalO365APIAppRole in $ServicePrincipalO365APIAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIAppRole.Id,\"Role\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Delegated permissions for Office 365 API Write-output \"Get all the Resource Access objects for the Delegated permissions for Office 365 API\" foreach ($ServicePrincipalO365APIDelegatedRole in $ServicePrincipalO365APIDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIDelegatedRole.Id,\"Scope\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Application permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Application permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphAppRole in $ServicePrincipalMicrosoftGraphAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphAppRole.Id,\"Role\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API Write-Output \"Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API\" foreach ($ServicePrincipalMicrosoftGraphDelegatedRole in $ServicePrincipalMicrosoftGraphDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphDelegatedRole.Id,\"Scope\" $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission } # Assign all the permissions to the required Resource access for the O365 API $RequiredResourceAccessO365API.ResourceAccess = $ServicePrincipalO365APIAppRolesSelectedPermissions # Assign all the permissions to the required Resource access for the Microsoft Graph $RequiredResourceAccessMicrosoftGraph.ResourceAccess = $ServicePrincipalSelectedPermissionsMicrosoftGraph # Create the Password credential for the new app Add-Type -AssemblyName System.Web $ApplicationPassword =[System.Web.Security.Membership]::GeneratePassword(32,2) $ApplicationPassword = $ApplicationPassword.Replace(\"+\",\"_\") $ApplicationPassword = $ApplicationPassword.Replace(\"-\",\"_\") $keyId = (New-Guid).ToString(); $fromDate = [System.DateTime]::Now $durationInYears = 5 $endDate = $fromDate.AddYears($durationInYears) $Applicationkey = New-Object Microsoft.Open.AzureAD.Model.PasswordCredential($null, $endDate, $keyId, $fromDate, $ApplicationPassword) # Create the new app with the password cred $aadApplication = New-AzureADApplication -DisplayName $ApplicationDisplayName -PasswordCredentials $Applicationkey write-output(\"Application created\") # Set the permissions Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $RequiredResourceAccessO365API,$RequiredResourceAccessMicrosoftGraph write-output(\"Application permissions set\") # Saving the details for the app $temp_location = (get-location).Drive.Root+\"office365_temp\\\" $temp_file = $temp_location + $CurrentTimestamp+\".txt\" New-Item $temp_location -ItemType Directory -Force | Out-Null New-Item $temp_file -ItemType File -Force | Out-Null Add-Content $temp_file (\"Azure AD App display name: \" + $aadApplication.DisplayName) Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain) Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId) Add-Content $temp_file (\"App ClientId: \" + $aadApplication.AppId) Add-Content $temp_file (\"App Password: \" + $ApplicationPassword) .\\notepad.exe $temp_file write-output(\"Application details written to the file\") }else{ write-output(\"AzureAD application '\" + $AzureADAppForSplunk.DisplayName + \"' already exists.\") } The powershell script got executed and we can see the newly created app in the Azure portal:","title":"Step 1 - PowerShell script to Create the app"},{"location":"SetupAzureADAppForSplunk/#step-2-provide-app-details-to-splunk-admin","text":"The details for the newly created app is opened in the Notepad. This should be sent to the Splunk Administrator so they could set up the Splunk Add-on for O365 for this tenant.","title":"Step 2 - Provide app details to Splunk Admin"},{"location":"SetupAzureADAppForSplunk/#step-3-grant-admin-consent-in-azure-portal","text":"Log in to the Azure portal as Global Administrator. Navigate to Azure Active Directory > App Registrations > Click on \"All Applications\" > Go to \"Splunk app for Office 365\". In the app, click on \"API Permissions\". Notice all the permissions have already been assigned via the script. Click on \"Grant admin consent for tenant\" After the admin consent grant, It should look like below :","title":"Step 3 - Grant Admin Consent in Azure Portal"}]}