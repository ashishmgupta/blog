{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Microsoft O365 Security Implementation","text":"<p>Below are the best practices we can implement to secure Microsoft O365.  I will regularly update this with the latest security features as they are published.  Below can also be accessed from the left navigation pane. </p> <ul> <li>Setup AzureAD App For Splunk</li> <li>Set tenant properties</li> <li>Disable Security Defaults</li> <li>Create Emergency User</li> <li>Implement MFA</li> <li>Block OFAC Countries</li> <li>Disable basic authentication</li> <li>Restrict External Collaboration</li> <li>Restrict User Settings</li> <li>Block Misc Azure Services for non-admin users</li> </ul> <p>[ The main blog ]</p>"},{"location":"BlockMiscAzureServices/","title":"Block Misc Azure Services for non-admin users","text":""},{"location":"BlockMiscAzureServices/#blocking-the-graph-explorer-app-and-services-under-the-microsoft-azure-management-app","title":"Blocking the \"Graph Explorer\" app and services under the \"Microsoft Azure Management\" app.","text":"<p>We would want to restrict access to various Azure services to non-admin users because they don't need that access.  Graph Explorer is one of the apps we want to disable access to unless It's a business requirement not to do so.  Some of the other services fall under the umbrella of an in-built Azure App named \"Microsoft Azure management\". So, if we block access to this app for non-admin users, the services under them will be unavailable to non-admin users.  Below are the services under \"Microsoft Azure management\". </p> <ul> <li>Azure portal</li> <li>Azure Resource Manager provider</li> <li>Classic deployment model APIs</li> <li>Azure PowerShell</li> <li>Azure CLI</li> <li>Azure DevOps</li> <li>Azure Data Factory portal</li> <li>Azure Event Hubs</li> <li>Azure Service Bus</li> <li>Azure SQL Database</li> <li>SQL Managed Instance</li> <li>Azure Synapse</li> <li>Visual Studio subscriptions administrator portal</li> </ul> <p>Source : https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/concept-conditional-access-cloud-apps </p> <p>Below is the PowerShell script to create the conditional access policy which would restrict access to the above services to all users except admins.</p> <pre><code># Connect to AzureAD and get current logged in user\n$TenantDetails = $NULL\n$CurrentlyLoggedInUser = $NULL\n$OnMicrosoftDomain = $NULL\n$connection = $NULL\ntry { \n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n    $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n} \ncatch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { \n    Write-Host \"You're not connected to AzureAD. Connect now...\"; \n    Write-Host \"You're not connected to AzureAD\"; \n    $connection = Connect-AzureAD\n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n    $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n}\n\n\n$AdminRolesIds = Get-AzureADMSROleDefinition | Where-Object -FilterScript {$_.DisplayName -like '*Administrator'}| select -ExpandProperty Id\n\n# Create the conditional access policy to block access from all OFAC countries to all apps for all users except the currently logged in user\n\n$conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet\n$conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition\n$conditions.Applications.IncludeApplications = \"797f4846-ba00-4fd7-ba43-dac1f8f63013\", \"de8bc8b5-d9f9-48b1-a8ad-b748da725064\"\n$conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition\n$conditions.Users.IncludeUsers = \"all\"\n$conditions.Users.ExcludeRoles = $AdminRolesIds\n$controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls\n$controls._Operator = \"OR\"\n$controls.BuiltInControls = \"block\"\nNew-AzureADMSConditionalAccessPolicy -DisplayName \"Block Misc Azure apps for non-admin users\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls\nWrite-output \"Conditional Access Policy created.\\r\"\n</code></pre> <p> We can see the conditional access policy has been created to block ALL users(except those in admin roles) from accessing services included under \"Microsoft Azure Management\"</p>"},{"location":"BlockMiscAzureServices/#tests","title":"Tests","text":""},{"location":"BlockMiscAzureServices/#graph-explorer-access-denied-to-a-non-admin-user","title":"Graph explorer access denied to a non-admin user","text":"<p>Access is denied to the non-admin user.  </p>"},{"location":"BlockMiscAzureServices/#azure-portal-access-denied-to-a-non-admin-user","title":"Azure portal access denied to a non-admin user","text":"<p>Azure Portal (part of the \"Microsoft Azure Management\" app) Access is denied to the non-admin user. </p>"},{"location":"BlockOFACCountries/","title":"Block OFAC Countries","text":"<p>In case we have a requirement to block requests from certain countries , we can use conditional policy to achieve the same. As a first step, we create a \"named location\" which has the list of countries we need to block all requests from.  Then we create a conditional access policy to use that country list to implement the block. ALL users would be blocked from OFAC countries except the currently logged in user.</p> <p>A useful website to look for ISO codes (among others) for countries is  https://countrycode.org.   The PowerShell script to create the named location and conditional access policy for the block: </p> <pre><code># Connect to AzureAD and get current logged in user\n$TenantDetails = $NULL\n$CurrentlyLoggedInUser = $NULL\n$OnMicrosoftDomain = $NULL\n$connection = $NULL\ntry { \n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n    $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n} \ncatch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { \n    Write-Host \"You're not connected to AzureAD. Connect now...\"; \n    Write-Host \"You're not connected to AzureAD\"; \n    $connection = Connect-AzureAD\n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n    $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n}\n\n\n$NamedLocationPolicyName = \"OFAC Countries\"\n\n$NamedLocationPolicy = Get-AzureADMSNamedLocationPolicy | Where-Object {$_.DisplayName -eq $NamedLocationPolicy}\nif ($NamedLocationPolicy -eq $null)\n{\n    # Create a named location policy which includes all the OFAC Countries.\n    $NamedLocationPolicy = New-AzureADMSNamedLocationPolicy -OdataType \"#microsoft.graph.countryNamedLocation\" -DisplayName $NamedLocationPolicyName -CountriesAndRegions \"BY\",\"BI\",\"BA\",\"CD\",\"CF\",\"CI\",\"CN\",\"CU\",\"IQ\",\"IR\",\"KP\",\"LR\",\"MD\",\"ME\",\"MK\",\"NI\",\"RU\",\"RS\",\"SD\",\"SS\",\"SY\",\"UA\",\"VE\",\"YE\",\"ZW\",\"AU\" -IncludeUnknownCountriesAndRegions $false\n    Write-Host \"Named location policy : \" + $NamedLocationPolicyName + \" has been created.\"\n    Write-Host \"Countries included : \" + $NamedLocationPolicyName.CountriesAndRegions\n}else{\n    Write-Host \"Named location policy : \" + $NamedLocationPolicyName + \" already exists.\"\n    Write-Host \"Countries included : \" + $NamedLocationPolicyName.CountriesAndRegions\n}\n\n# Create the conditional access policy to block access from all OFAC countries to all apps for all users except the currently logged in user\n\n$conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet\n$conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition\n$conditions.Applications.IncludeApplications = \"all\"\n$conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition\n$conditions.Users.IncludeUsers = \"all\"\n$conditions.Users.ExcludeUsers = $CurrentUserId\n$conditions.Locations = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessLocationCondition\n$conditions.Locations.IncludeLocations = $NamedLocationPolicy.Id\n$controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls\n$controls._Operator = \"OR\"\n$controls.BuiltInControls = \"block\"\nNew-AzureADMSConditionalAccessPolicy -DisplayName \"Block OFAC countries\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls\n</code></pre> <p>  The conditional access policy is created.     The conditional access policy showing block condition for the location noted in the named location \"OFAC Countries\".  </p>"},{"location":"CreateEmergencyUser/","title":"Create Emergency User","text":"<p>We protect our users by enforcing Azure MFA.  However, Azure MFA has gone down before and we dont want administrators to be locked out of tennat to troubleshoot if this happens again.    Therefore, we create a cloud-only \"emergency\" account. This account will be assigned a Global Admin role and wont have the MFA enforced on it. This account should be used ONLY when Azure MFA service is down. Given high privileges on this account, any attempt of usage this emergency login should generate a high alert for Security Opertion Center to validate the legit use. </p> <p>The PowerShell script  : </p> <pre><code>$TenantDetails = $NULL\n$CurrentlyLoggedInUser = $NULL\n$OnMicrosoftDomain = $NULL\n$connection = $NULL\n$CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\")\ntry { \n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n\n} \ncatch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { \n    Write-Host \"You're not connected to AzureAD. Connecting now...\"; \n    $connection = Connect-AzureAD\n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n}\n$CurrentlyLoggedInUser\n$CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n$EmergencyUserUPNPrefix = \"EmUser\"\n$UserDisplayName = \"EmergencyUser\"\n$TenantDomain = $Connection.TenantDomain\n$OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@'))\n$OnMicrosoftDomain\n$UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain\n\n\n$EmUser = $NULL\n\ntry{\n    $EmUser = Get-AzureADUser -ObjectId $UserPrincipalName -ErrorAction silentlycontinue\n    write-output(\"Emergency user \" + $UserPrincipalName + ' already exists.')\n}catch{\n    write-output(\"Emergency user \" + $UserPrincipalName + ' does not exist. Creating now..')\n    Add-Type -AssemblyName System.Web\n    $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2)\n    $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile\n    $PasswordProfile.Password = $UserPassword\n    $UserPassword\n    $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\"\n\n    # Adding the new user to Global Admin role\n    Write-output \"Adding the new user to Global Admin r+ole\"\n    $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq  \"Global Administrator\"} \n    Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId \n\n    # Saving the details for the app\n    $temp_location = (get-location).Drive.Root+\"office365_temp\\\"\n    $temp_file = $temp_location + $CurrentTimestamp+\".txt\"\n    New-Item $temp_location -ItemType Directory -Force | Out-Null\n    New-Item $temp_file -ItemType File -Force | Out-Null\n    Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain)\n    Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId)\n    Add-Content $temp_file (\"Username: \" + $UserPrincipalName)\n    Add-Content $temp_file (\"Password: \" + $UserPassword)\n    .\\notepad.exe $temp_file\n    write-output(\"User details written to the file\\r\\n\")\n}\n</code></pre> <p>The emergency user is created.  </p> <p>The emergency user is assigned the Global Administrator role on permanent basis.  </p>"},{"location":"Detection-CloudOnlyAccountCreated/","title":"Create Account: Cloud Account (Subtechnique T1136.003)","text":""},{"location":"Detection-CloudOnlyAccountCreated/#attack-technique","title":"Attack technique","text":"<p>The Below script will create a cloud-only account in Azure AD.</p> <pre><code>$TenantDetails = $NULL\n$CurrentlyLoggedInUser = $NULL\n$OnMicrosoftDomain = $NULL\n$connection = $NULL\n$CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\")\ntry { \n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n\n} \ncatch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { \n    Write-Host \"You're not connected to AzureAD. Connecting now...\"; \n    $connection = Connect-AzureAD\n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n}\n$CurrentlyLoggedInUser\n$CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n\n$EmergencyUserUPNPrefix = Read-Host(\"Enter the name of the user you want to create or hit enter for the script to create one.\")\nif($EmergencyUserUPNPrefix -eq \"\")\n{\n    $EmergencyUserUPNPrefix = \"TempUser_\" + $CurrentTimestamp\n}\n$UserDisplayName = $EmergencyUserUPNPrefix \n$TenantDomain = $Connection.TenantDomain\n$OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@'))\n$OnMicrosoftDomain\n$UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain\n\n$EmUser = $NULL\n\ntry{\n    $EmUser = Get-AzureADUser -ObjectId $UserPrincipalName -ErrorAction silentlycontinue\n    write-output(\"Emergency user \" + $UserPrincipalName + ' already exists.')\n}catch{\n    write-output(\"Emergency user \" + $UserPrincipalName + ' does not exist. Creating now..')\n    Add-Type -AssemblyName System.Web\n    $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2)\n    $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile\n    $PasswordProfile.Password = $UserPassword\n    $UserPassword\n    $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\"\n\n    # Adding the new user to Global Admin role\n    Write-output \"Adding the new user to Global Admin r+ole\"\n    $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq  \"Global Administrator\"} \n    Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId \n\n    # Saving the details for the app\n    $temp_location = (get-location).Drive.Root+\"office365_temp\\\"\n    $temp_file = $temp_location + $CurrentTimestamp+\".txt\"\n    New-Item $temp_location -ItemType Directory -Force | Out-Null\n    New-Item $temp_file -ItemType File -Force | Out-Null\n    Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain)\n    Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId)\n    Add-Content $temp_file (\"Username: \" + $UserPrincipalName)\n    Add-Content $temp_file (\"Password: \" + $UserPassword)\n    .\\notepad.exe $temp_file\n    write-output(\"User details written to the file\\r\\n\")\n}\n</code></pre> <p>When the script is run, It asks the name of the user to be created. If we just hit enter, It creates a user named \"TempUser_\" followed by the current date-time.    Azure AD user is created as seen in the Azure portal.   </p>"},{"location":"Detection-CloudOnlyAccountCreated/#splunk-detections","title":"Splunk Detections","text":""},{"location":"Detection-CloudOnlyAccountCreated/#create-user-event","title":"Create user event","text":"<pre><code>index=azure sourcetype=\"azure:aad:audit\" activityDisplayName=\"Add user\" result=\"success\"\n| spath targetResources{}\n| rename targetResources{}.userPrincipalName as UserAdded initiatedBy.user.userPrincipalName as CreatedByUPN  additionalDetails{}.value as UserAgent\n| table _time UserAdded CreatedByUPN  UserAgent\n</code></pre> <p> Newly created user is found in the search.  </p> <p>Note : \"Swagger-Codegen/1.4.0.0/csharp\" is the user agent when Azure AD PowerShell is used to create the user. </p>"},{"location":"Detection-CloudOnlyAccountCreated/#the-user-was-created-outside-pim-eg-powershell","title":"The User was created outside PIM (e.g. PowerShell)","text":"<pre><code>index=azure operationType=\"RoleElevatedOutsidePimAlert\" result=\"success\" \n| rename targetResources{}.displayName as key_5, targetResources{}.userPrincipalName as key_6\n| eval a = mvzip(key_5,key_6)\n| makemv a delim=\",\"\n| eval RoleNameUserAddedto  = mvindex(a,0)\n| eval UserAdded = mvindex(a,3)\n| rename initiatedBy.user.displayName as CreatedByName, initiatedBy.user.userPrincipalName as CreatedByUPN\n| table _time UserAdded RoleNameUserAddedto CreatedByName CreatedByUPN \n</code></pre>"},{"location":"Detection-ConditionalAccessPolicyChanged/","title":"Detection ConditionalAccessPolicyChanged","text":"<p>''' index=\"main\"  sourcetype=\"azure:aad:audit\" result=\"success\" activityDisplayName=\"Update conditional access policy\" | rename initiatedBy.user.userPrincipalName as policyChangedBy | rename targetResources{}.displayName as policyName | spath targetResources{}.modifiedProperties{}.newValue output=newvalue | spath targetResources{}.modifiedProperties{}.oldValue output=oldvalue</p> <p>| spath input=newvalue conditions output=newConditions | mvexpand newConditions | spath input=oldvalue conditions output=oldConditions | mvexpand oldConditions | spath input=newConditions users output=newUsers | spath input=oldConditions users output=oldUsers | eval usersChanged=if(tostring(oldUsers)==tostring(newUsers), \"Not changed\", \"Changed\") | spath input=newConditions platforms output=newPlatforms | spath input=oldConditions platforms output=oldPlatforms | eval platformsChanged=if(tostring(oldPlatforms)==tostring(newPlatforms), \"Not changed\", \"Changed\") | spath input=newConditions locations output=newLocations | spath input=oldConditions locations output=oldLocations | eval locationsChanged=if(tostring(oldLocations)==tostring(newLocations), \"Not changed\", \"Changed\") | spath input=newConditions applications output=newApplications | spath input=oldConditions applications output=oldApplications | eval applicationsChanged=if(tostring(oldApplications)==tostring(newApplications), \"Not changed\", \"Changed\") | spath input=newConditions userRiskLevels output=newUserRiskLevels | spath input=oldConditions userRiskLevels output=oldUserRiskLevels | eval userRiskLevelsChanged=if(tostring(oldUserRiskLevels)==tostring(newUserRiskLevels), \"Not changed\", \"Changed\") | spath input=newConditions signInRiskLevels output=newSignInRiskLevels | spath input=oldConditions signInRiskLevels output=oldSignInRiskLevels | eval signInRiskLevelsChanged=if(tostring(oldSignInRiskLevels)==tostring(newSignInRiskLevels), \"Not changed\", \"Changed\") | spath input=newConditions clientAppTypes output=newClientAppTypes | spath input=oldConditions clientAppTypes output=oldClientAppTypes | eval clientAppTypesChanged=if(tostring(oldClientAppTypes)==tostring(newClientAppTypes), \"Not changed\", \"Changed\") | spath input=newConditions devices output=newDevices | spath input=oldConditions devices output=oldDevices | eval devicesChanged=if(tostring(oldDevices)==tostring(newDevices), \"Not changed\", \"Changed\") | spath input=newConditions servicePrincipalRiskLevels output=newServicePrincipalRiskLevels | spath input=oldConditions servicePrincipalRiskLevels output=oldServicePrincipalRiskLevels | eval servicePrincipalRiskLevelsChanged=if(tostring(oldServicePrincipalRiskLevels)==tostring(newServicePrincipalRiskLevels), \"Not changed\", \"Changed\") | spath input=newvalue grantControls output=newGrantControls | spath input=oldvalue grantControls output=oldGrantControls | eval grantControlsChanged=if(tostring(oldGrantControls)==tostring(newGrantControls), \"Not changed\", \"Changed\") | table _time policyName policyChangedby oldGrantControls newGrantControls oldUsers newUsers usersChanged oldPlatforms newPlatforms platformsChanged oldLocations newLocations locationsChanged oldApplications newApplications applicationsChanged oldUserRiskLevels newUserRiskLevels userRiskLevelsChanged oldSignInRiskLevels newSignInRiskLevels signInRiskLevelsChanged oldClientAppTypes newClientAppTypes clientAppTypesChanged oldDevices newDevices devicesChanged oldServicePrincipalRiskLevels newServicePrincipalRiskLevels servicePrincipalRiskLevelsChanged oldGrantControls newGrantControls grantControlsChanged '''</p>"},{"location":"Detection-UserAddedToAdminRole/","title":"Account Manipulation: Additional Cloud Roles","text":""},{"location":"Detection-UserAddedToAdminRole/#about","title":"About","text":"<p>An adversary can create an account and then add it to a privileged role such as Global Administrator.  Tactic    : Persistence  Technique : Account Manipulation More details here in  MITRE ATT&amp;CK  . </p>"},{"location":"Detection-UserAddedToAdminRole/#attack-simulation","title":"Attack Simulation","text":"<p>The below script creates an account and adds the account to the Global administrator role. </p> <pre><code>$TenantDetails = $NULL\n$CurrentlyLoggedInUser = $NULL\n$OnMicrosoftDomain = $NULL\n$connection = $NULL\n$CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\")\ntry { \n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n\n} \ncatch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { \n    Write-Host \"You're not connected to AzureAD. Connecting now...\"; \n    $connection = Connect-AzureAD\n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n}\n$CurrentlyLoggedInUser\n$CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n\n$EmergencyUserUPNPrefix = Read-Host(\"Enter the name of the user you want to create or hit enter for the script to create one.\")\nif($EmergencyUserUPNPrefix -eq \"\")\n{\n    $EmergencyUserUPNPrefix = \"TempUser_\" + $CurrentTimestamp\n}\n$UserDisplayName = $EmergencyUserUPNPrefix \n$TenantDomain = $Connection.TenantDomain\n$OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@'))\n$OnMicrosoftDomain\n$UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain\n\n$EmUser = $NULL\n\ntry{\n    $EmUser = Get-AzureADUser -ObjectId $UserPrincipalName -ErrorAction silentlycontinue\n    write-output(\"Emergency user \" + $UserPrincipalName + ' already exists.')\n}catch{\n    write-output(\"Emergency user \" + $UserPrincipalName + ' does not exist. Creating now..')\n    Add-Type -AssemblyName System.Web\n    $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2)\n    $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile\n    $PasswordProfile.Password = $UserPassword\n    $UserPassword\n    $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\"\n\n    # Adding the new user to Global Admin role\n    Write-output \"Adding the new user to Global Admin role\"\n    $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq  \"Global Administrator\"} \n    Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId \n\n    # Saving the details for the app\n    $temp_location = (get-location).Drive.Root+\"office365_temp\\\"\n    $temp_file = $temp_location + $CurrentTimestamp+\".txt\"\n    New-Item $temp_location -ItemType Directory -Force | Out-Null\n    New-Item $temp_file -ItemType File -Force | Out-Null\n    Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain)\n    Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId)\n    Add-Content $temp_file (\"Username: \" + $UserPrincipalName)\n    Add-Content $temp_file (\"Password: \" + $UserPassword)\n    .\\notepad.exe $temp_file\n    write-output(\"User details written to the file\\r\\n\")\n}\n</code></pre> <p>Azure AD user is assigned the Global Admin role as seen in the Azure portal.   </p>"},{"location":"Detection-UserAddedToAdminRole/#splunk-detection","title":"Splunk Detection","text":""},{"location":"Detection-UserAddedToAdminRole/#user-added-to-the-administrator-role","title":"User added to the administrator role","text":"<pre><code>index=azure sourcetype=\"azure:aad:audit\" activityDisplayName=\"Add member to role\" result=\"success\"\n| eval AssignedRoleName = mvindex('targetResources{}.modifiedProperties{}.newValue', mvfind('targetResources{}.modifiedProperties{}.displayName', \"Role\\.DisplayName\"))\n| eval RoleWellKnownObjectName = mvindex('targetResources{}.modifiedProperties{}.newValue', mvfind('targetResources{}.modifiedProperties{}.displayName', \"Role\\.WellKnownObjectName\"))\n| search AssignedRoleName = \"*Administrator*\"\n| rename targetResources{}.userPrincipalName as UserAddedToRole, initiatedBy.user.ipAddress as src_ip, initiatedBy.user.userPrincipalName as CreatedByUPN\n| table _time UserAddedToRole, AssignedRoleName, src_ip ,CreatedByUPN,  roleWellKnownObjectName\n</code></pre>"},{"location":"Detection-UserAddedToAdminRole/#the-user-was-created-outside-pim-eg-powershell","title":"The User was created outside PIM (e.g. PowerShell)","text":"<p>When the user is assigned to an administrator role without using Azure AD Privileged Identity Management (PIM), a corresponding Azure Ad event \"RoleElevatedOutsidePimAlert\" is generated and we would want to detect such an event. Any privileged role assignment should be done only through PIM. </p> <pre><code>index=azure operationType=\"RoleElevatedOutsidePimAlert\" result=\"success\" \n| rename targetResources{}.displayName as key_5, targetResources{}.userPrincipalName as key_6\n| eval a = mvzip(key_5,key_6)\n| makemv a delim=\",\"\n| eval RoleNameUserAddedto  = mvindex(a,0)\n| eval UserAdded = mvindex(a,3)\n| rename initiatedBy.user.displayName as CreatedByName, initiatedBy.user.userPrincipalName as CreatedByUPN\n| table _time UserAdded RoleNameUserAddedto CreatedByName CreatedByUPN \n</code></pre>"},{"location":"DisableBasicAuth/","title":"Disable basic authentication","text":""},{"location":"DisableBasicAuth/#what-is-basic-authentication","title":"What is Basic Authentication?","text":"<p>User-supplied username and password are joined and separated by a colon and base64 encoded.  The base64 encoded value is sent as an HTTP header named \"Authorization\". For example, if the user enters \"admin\" as the user name and \"P@ssw0rd\" as the password, the base64 encoded value would be \"YWRtaW46UEBzc3cwcmQ\" The HTTP header would be like the below : Authorization: Basic YWRtaW46UEBzc3cwcmQ </p>"},{"location":"DisableBasicAuth/#basiclegacyprotocolsauthentication-","title":"Basic/Legacy/Protocols/Authentication???? :-$","text":"<p>Sometimes, It gets very confusing when terms like \"basic\" and \"legacy\" are used for both protocols and auth.  Therefore, It is very important to understand the difference between the messaging protocols vs the authentication mechanism.  The authentication mechanism is a part of messaging protocol which also deals with how the messages would be exchanged between the client and the server after authentication. </p> <p>Let's look at the IMAP4 protocol.  https://datatracker.ietf.org/doc/html/rfc3501 </p> <p>You see the \"Authenticated\" step which means how clients would authenticate to the server and also the \"Selected\" step has the SELECT command selects a mailbox so that messages in the mailbox can be accessed. </p> <p>That \"Authenticated\" step may make use of Basic authentication (like we described above). However, that option of using basic auth should be disabled so clients (potential attackers) cant make use of the same.</p>"},{"location":"DisableBasicAuth/#why-basic-auth-is-discouraged","title":"Why basic auth is discouraged?","text":"<p>Since the authentication is possible by simply sending the base64 encoded user name and password, It is more prone to brute force and password spraying attacks. It's possible to send the creds over basic auth over HTTP in which case It may be captured by an attacker and decoded back to original plain text credentials.</p> <p>We create an authentication policy that has by default basic auth disabled for all protocols.  And then set the default authentication policy for the whole organization the newly created authentication policy</p> <pre><code>New-AuthenticationPolicy -Name \"Block Legacy Auth for all protocols\"\n</code></pre> <p>By default, the basic auth is disabled for all protocols.  </p> <p>Setting the newly created policy with basic auth disabled as the default policy for the organization/tenant. </p> <pre><code>Set-OrganizationConfig -DefaultAuthenticationPolicy \"Block Legacy Auth for all protocols\"\n</code></pre> <p>Check the newly created authentication policy :  </p> <p>The default authentication policy is set to the newly created authentication policy. </p> <pre><code>Get-OrganizationConfig | select DefaultAuthenticationPolicy\n</code></pre>  <p>We can also check the Microsoft Admin Center. Go to Microsoft 365 Admin Center  Settings &gt; Org Settings &gt; Modern Authentication  All the settings except the \"Turn on modern authentication for Outlook 2013 for Windows and later (recommended)\" should be unchecked.  </p>"},{"location":"DisableBasicAuth/#enable-modern-authentication","title":"Enable Modern Authentication","text":"<pre><code>Set-OrganizationConfig -OAuth2ClientProfileEnabled $true\n</code></pre>"},{"location":"DisableBasicAuth/#tests","title":"Tests","text":""},{"location":"DisableBasicAuth/#the-python-script","title":"The Python Script","text":"<p>To test the basic authentication, we will make use of the below script which tries to authenticate to Exchange Online with a given set of users using Exchange Web Services (EWS). EWS uses Autodiscover protocol which in turn could use basic authentication.</p> <p>The script can be found here as well:  https://github.com/ashishmgupta/pyAbuseLegacyAuthInEXO </p> <pre><code>from exchangelib import Credentials, Account\nimport requests\nimport os\nfrom pathlib import Path\nimport re\n\nexternal_ip = requests.get('https://ident.me').text\nprint(external_ip)\ncurrent_dir = os.getcwd()\ncreds_file = os.path.join(current_dir, \"creds.txt\")\nif not os.path.isfile(creds_file):\n    fp = open('creds_file', 'x')\n    fp.close()\n    print(\"Credentials file did not exist. We created a new one. Please populate with username and password separated by || in each line\")\n    quit()\n\nwith open(creds_file) as f:\n    lines = f.readlines()\n\nfor line in lines:\n    line = line.rstrip()\n    cred = line.split(\"||\")\n    username = cred[0]\n    password = cred[1]\n    print(username)\n    print(password)\n    credentials = Credentials(username, password)\n    account = Account(username, credentials=credentials, autodiscover=True)\n\n    user_folder= current_dir+\"/\"+username\n    Path(user_folder).mkdir(parents=True, exist_ok=True)\n\n    for msg in account.inbox.all().order_by('-datetime_received')[:10]:\n        email_content=\"\"\n        clean_subject = re.sub('[^A-Za-z0-9]+','', msg.subject )\n        msg_folder_to_save =  user_folder +\"/\"+clean_subject\n        msg_contents_file =  msg_folder_to_save +\"/msg.txt\"\n        Path(msg_folder_to_save).mkdir(parents=True, exist_ok=True)\n        #print(msg.subject, msg.sender, msg.datetime_received)\n\n        email_content += \"sender            ={}\".format(msg.sender) + \"\\n\"\n        email_content += \"datetime_sent     ={}\".format(msg.datetime_sent)+ \"\\n\"\n        email_content += \"subject           ={}\".format(msg.subject)+ \"\\n\"\n        email_content += \"text_body         ={}\".format(msg.text_body.encode('UTF-8'))+ \"\\n\"\n        with open(msg_contents_file, \"w+\") as f:\n            f.write(email_content)\n\n        print(email_content)\n        print(\"#\" * 80)\n        for attachment in msg.attachments:\n            fpath = os.path.join(msg_folder_to_save, attachment.name)\n            with open(fpath, 'wb') as f:\n                f.write(attachment.content)\n</code></pre>"},{"location":"DisableBasicAuth/#enabling-the-basic-auth-for-all-protocols","title":"Enabling the basic auth for all protocols","text":"<pre><code>Set-AuthenticationPolicy -Identity 'Block Legacy Auth for all protocols' -AllowBasicAuthAutodiscover -AllowBasicAuthActiveSync -AllowBasicAuthImap -AllowBasicAuthMapi -AllowBasicAuthOfflineAddressBook -AllowBasicAuthOutlookService -AllowBasicAuthPop -AllowBasicAuthPowershell -AllowBasicAuthReportingWebServices -AllowBasicAuthRpc -AllowBasicAuthSmtp -AllowBasicAuthWebServices\n</code></pre> <p> Basic auth enabled for all protocols. </p> <p> Executing the Python script.  Could retrieve all the messages from the mailbox. </p>"},{"location":"DisableBasicAuth/#disabling-the-basic-auth-for-all-protocols","title":"Disabling the basic auth for all protocols","text":"<pre><code>Set-AuthenticationPolicy -Identity 'Block Legacy Auth for all protocols' -AllowBasicAuthAutodiscover:$false -AllowBasicAuthActiveSync:$false -AllowBasicAuthImap:$false -AllowBasicAuthMapi:$false -AllowBasicAuthOfflineAddressBook:$false -AllowBasicAuthOutlookService:$false -AllowBasicAuthPop:$false -AllowBasicAuthPowershell:$false -AllowBasicAuthReportingWebServices:$false -AllowBasicAuthRpc:$false -AllowBasicAuthSmtp:$false -AllowBasicAuthWebServices:$false \n</code></pre> <p> Basic auth disabled for all protocols.  </p> <p>The test will fail with below error : </p> <p> exchangelib.errors.AutoDiscoverFailed: All steps in the autodiscover protocol failed for email 'email'. If you think this is an error, consider doing an official test at https://testconnectivity.microsoft.com     </p>"},{"location":"DisableSMTPAuth/","title":"DisableSMTPAuth","text":""},{"location":"DisableSMTPAuth/#tests","title":"Tests","text":"<p>Below code tries to use Basic Auth over SMTP Auth protocol and fails becuase SMTP Auth is disabled</p> <p>$creds = get-credential</p> <p>Send-MailMessage \u2013From donaldblake@redteamsimulation.com \u2013To ashishxxx@xxx.com \u2013Subject \"Test Email\" \u2013Body \"Test SMTP Service from Powershell\" -SmtpServer smtp.office365.com -Credential $creds -UseSsl -Port 587</p> <p>Error Message : Send-MailMessage : The SMTP server requires a secure connection or the client was not authenticated. The server response was: 5.7.57 Client not authenticated to send mail. Error: 535 5.7.139 Authentication unsuccessful, SmtpClientAuthentication is disabled for the Tenant. Visit https://aka.ms/smtp_auth_disabled for more information. [BN0PR10CA0026.namprd10.prod.outlook.com] At line:1 char:1 + Send-MailMessage \u2013From donaldblake@redteamsimulation.com \u2013To ashishmg ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     + CategoryInfo          : InvalidOperation: (System.Net.Mail.SmtpClient:SmtpClient) [Send-MailMessage], SmtpExcept    ion     + FullyQualifiedErrorId : SmtpException,Microsoft.PowerShell.Commands.SendMailMessage</p>"},{"location":"DisableSecurityDefaults/","title":"Disable Security Defaults","text":"<p>Security Defaults is a set of basic identity security mechanisms recommended by Microsoft. When enabled, these recommendations will be automatically enforced in your organization. Source:  https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/concept-fundamentals-security-defaults</p> <p>That said, to be more flexible and wider security controls, you would use conditional access policies which require the security defaults to be disabled.</p> <p>Login to Azure portal &gt; Azure Active Directory &gt; Properties &gt; Manage Security Defaults &gt; Enable Security Defaults &gt; set to \"No\"  </p>"},{"location":"ImplementMFA/","title":"Implement MFA","text":"<p>We will create a conditional access policy to enforce all MFA on all users excluding an emergency Azure cloud-only Account.  Below is the PowerShell script for the same. If the emergency account does not exist, It will create the account before creating the conditional access policy. </p>"},{"location":"ImplementMFA/#the-powershell-script-to-enforce-mfa","title":"The PowerShell script to enforce MFA","text":"<pre><code>$TenantDetails = $NULL\n$CurrentlyLoggedInUser = $NULL\n$OnMicrosoftDomain = $NULL\n$connection = $NULL\ntry { \n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n\n} \ncatch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { \n    Write-Host \"You're not connected to AzureAD. Connecting now...\"; \n    $connection = Connect-AzureAD\n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n}\n$CurrentlyLoggedInUser\n$CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n$EmergencyUserUPNPrefix = \"EmUser\"\n$UserDisplayName = \"EmergencyUser\"\n$TenantDomain = $Connection.TenantDomain\n$OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@'))\n$OnMicrosoftDomain\n$UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain\n\n\n$EmUser = $NULL\n\ntry{\n    $EmUser = Get-AzureADUser -ObjectId $UserPrincipalName -ErrorAction silentlycontinue\n    write-output(\"Emergency user \" + $UserPrincipalName + ' already exists.')\n}catch{\n    write-output(\"Emergency user \" + $UserPrincipalName + ' does not exist. Creating now..')\n    Add-Type -AssemblyName System.Web\n    $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2)\n    $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile\n    $PasswordProfile.Password = $UserPassword\n    $UserPassword\n    $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\"\n\n    # Adding the new user to Global Admin role\n    Write-output \"Adding the new user to Global Admin r+ole\"\n    $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq  \"Global Administrator\"} \n    Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId \n\n    # Saving the details for the app\n    $temp_location = (get-location).Drive.Root+\"office365_temp\\\"\n    $temp_file = $temp_location + $CurrentTimestamp+\".txt\"\n    New-Item $temp_location -ItemType Directory -Force | Out-Null\n    New-Item $temp_file -ItemType File -Force | Out-Null\n    Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain)\n    Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId)\n    Add-Content $temp_file (\"Username: \" + $UserPrincipalName)\n    Add-Content $temp_file (\"Password: \" + $UserPassword)\n    .\\notepad.exe $temp_file\n    write-output(\"User details written to the file\\r\\n\")\n}\n\n    $conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet\n    $conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition\n    $conditions.Applications.IncludeApplications = \"all\"\n    $conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition\n    $conditions.Users.IncludeUsers = \"all\"\n    $conditions.Users.ExcludeUsers = $EmUser.ObjectId\n    $controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls\n    $controls._Operator = \"OR\"\n    $controls.BuiltInControls = \"mfa\"\n    New-AzureADMSConditionalAccessPolicy -DisplayName \"Enforce MFA on all users\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls\n    Write-Output \"Conditional Access policy created\"\n</code></pre> <p> Conditional Access policy is created. </p> <p> MFA is enforced for all apps. </p> <p> MFA is enforced for all users except the emergency global admin user. </p>"},{"location":"ImplementMFA/#number-matching-currently-in-preview","title":"Number matching (Currently in preview)","text":"<p>As of the day of writing this (5/23/2022), this feature is in preview and not GA. However, It will be enabled by default when It goes GA just because of added security and great user experience.</p> <p> Just like password fatigue caused users to re-use passwords and get compromised If we use push notifications for MFA, and if an attacker constantly sends push notifications to users with compromised credentials, users would eventually push and that would lead to the attacker accessing the user's cloud resources. </p> <p>To counter \"push fatigue\" [ a made-up term :)], Microsoft launched a new feature named \"Number matching\" (currently in preview).  https://docs.microsoft.com/en-us/azure/active-directory/authentication/how-to-mfa-number-match</p> <p>Login to Azure Portal &gt; Azure Active Directory &gt; Security &gt; Authentication methods and click on the \"Microsoft Authenticator\"  </p> <p>Click on the \"...\" and then configure.  </p> <p>Make sure \"Require number matching\" is set to \"Enabled\".  Also, make sure the \"Show additional context in notification\" is also enabled.  This provides for which app the login is being performed.  </p> <p>Now when the user logs in, after the user name and password has been validated, the browser shows a number and a notification is sent to the Microsoft Authenticator. We need to enter the same number in the authenticator to be successfully and fully authenticated via MFA.</p>   Bworser shows the number during log in process Enter the same number in the Microsoft Authenticator app       <p>I notice the number is always double-digit (not 5 or 6 digits). So, not only It adds to security by having the user enter the number (instead of an ignorant push) but also Its a great user experience because It's just two digits and easy to remember.</p>"},{"location":"MITRE-ATT%26CK-O365/","title":"MITRE ATT&CK O365","text":"<p>https://attack.mitre.org/matrices/enterprise/cloud/office365/ </p> <p>Tactics:     Initial Access         Techniques             Phishing (URL rewriting, Proofpoint/Mimecast)             Valid Accounts     Persistence         Techniques             Account Manipulation                 Grant additional email delegate permissions                 Add-MailboxPermission -User admin@contoso.com -AccessRights FullAccess -InheritanceType All             Create Account                 Splunk detection of creating a user with onmicrosoft.com domain name.             Office Application Startup             Valid Accounts     Privilege Escalation         Techniques             Valid Accounts     Defense Evasion         Techniques             Hide Artifacts             Impair Defenses             Use Alternate Authentication material             Valid Accounts     Credential Access         Techniques             Brute Force             Force Web Credentials             Multi-factor Authentication request Generation             Steal Application Access Token             Steal Web Session Cookie             Unsecured Credentials     Discovery         Techniques             Internal Spearphishing             Taint Shared Content             Use Alternate Authentication Material     Collection         Techniques             Data from Information repositories             Email Collection     Impact         Techniques             Account Access removal             Endpoint Denial of Service             Network Denial of Service</p>"},{"location":"MITRE-ATT%26CK-O365/#account-created-outside-pim","title":"Account created outside PIM","text":"<p>index=azure operationType=\"RoleElevatedOutsidePimAlert\" result=\"success\"  | rename targetResources{}.displayName as key_5, targetResources{}.userPrincipalName as key_6 | eval a = mvzip(key_5,key_6) | makemv a delim=\",\" | eval RoleNameUserAddedto  = mvindex(a,0) | eval UserAdded = mvindex(a,3) | rename initiatedBy.user.displayName as CreatedByName, initiatedBy.user.userPrincipalName as CreatedByUPN | table _time UserAdded RoleNameUserAddedto CreatedByName CreatedByUPN activityDisplayName</p>"},{"location":"RestrictExtarnelCollaboration/","title":"Restrict External Collaboration","text":"<p>If there is no business use case for external collaboration, set it to most restrictive settings.  Azure Portal &gt; Azure Active Directory &gt; External Identities &gt; Extarnel Collaboration Settings </p>"},{"location":"RestrictUserSettings/","title":"Restrict User Settings","text":""},{"location":"RestrictUserSettings/#restrict-registration-of-new-azure-ad-applications","title":"Restrict registration of new Azure AD applications","text":"<p>It is important to control registration of Azure AD applications.  Azure Portal &gt; Azure Active Directory &gt; User Settings  </p>"},{"location":"RestrictUserSettings/#restrict-users-ability-to-consent-to-apps","title":"Restrict users' ability to consent to Apps.","text":"<p>It is important to restrict users' ability to consent for applications to access organization data With the below setting, we allow user consent only for applications that have been published by a verified publisher. </p> <pre><code>Set-AzureADMSAuthorizationPolicy -DefaultUserRolePermissions @{\"PermissionGrantPoliciesAssigned\" = @(\"managePermissionGrantsForSelf.microsoft-user-default-low\") }\n</code></pre> <p> When an application is marked as publisher verified, it means that the publisher has verified their identity using a Microsoft Partner Network account that has completed the verification process and has associated this MPN account with their application registration.  Source : Publisher verification overview</p>"},{"location":"SMTPAuthTests/","title":"SMTPAuthTests","text":"<pre><code># Sender Credentials\n# Sender and Recipient Info\n$MailFrom = \"ashish.gupta@lplfinancial.com\"\n$MailTo = \"ashishmgupta@hotmail.com\"\n\n$Username = \"infosec.test@lplfinancial.com\"\n$Password = \"bN1A&amp;Fwf018s8huq%Aff\"\n\n# Server Info\n$SmtpServer = \"smtp.office365.com\"\n$SmtpPort = \"587\"\n\n# Message stuff\n$MessageSubject = \"Microsoft .NET documentation\" \n$Message = New-Object System.Net.Mail.MailMessage $MailFrom,$MailTo\n$Message.IsBodyHTML = $true\n$Message.Subject = $MessageSubject\n$Message.Body = @'\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\nhttps://docs.microsoft.com\n&lt;/body&gt;\n&lt;/html&gt;\n'@\n\n# Construct the SMTP client object, credentials, and send\n$Smtp = New-Object Net.Mail.SmtpClient($SmtpServer,$SmtpPort)\n$Smtp.EnableSsl = $true\n$Smtp.Credentials = New-Object System.Net.NetworkCredential($Username,$Password)\n$Smtp.Send($Message)\n</code></pre>"},{"location":"SetupAzureADAppForSplunk/","title":"Setup AzureAD App For Splunk","text":"<p>This section covers setting up Azure AD apps for Splunk Add-ons so Azure and O365 logs could be ingested into Splunk.  This is one of the first steps we would do so all changes done after are logged into Splunk for security monitoring by SOC. </p> <p>The below script would create the app so It does not need to be created manually. When the script below executes successfully, It should create a file with creds for the app. Those details should be provided to the Splunk Administrator so they could set up the Azure tenant for the log ingestion.  The admin consent needs to be granted via the Azure portal (instructions below).</p> <p>We will need to create separate Azure AD apps for the below Splunk Add-ons Splunk Add-on for Microsoft Office 365  Microsoft Azure Add-on for Splunk</p>"},{"location":"SetupAzureADAppForSplunk/#pre-requisite-install-azure-ad-powershell","title":"Pre-requisite - Install Azure AD Powershell","text":"<p>Please execute the below in PowerShell to install the Azure AD module for Powershell</p> <pre><code>Install-Module AzureAD\n</code></pre> <p>Please ensure you are executing the above in Powershell v5.1 and not 7.x. Execute the below to ensure :</p> <pre><code>$PSVersionTable\n</code></pre>"},{"location":"SetupAzureADAppForSplunk/#pre-requisite-enable-unified-auditing-for-office-365","title":"Pre-requisite - Enable Unified Auditing for Office 365","text":"<p>Please enable this or Splunk app wont be able to get logs from the tenant.  Instructions are  straight forward.</p>"},{"location":"SetupAzureADAppForSplunk/#create-the-azure-ad-app-for-spunk-add-on-for-microsoft-office-365","title":"Create the Azure AD app for Spunk Add-on for Microsoft Office 365","text":""},{"location":"SetupAzureADAppForSplunk/#step-1-powershell-script-to-create-the-app","title":"Step 1 - PowerShell script to Create the app","text":"<p>Please ensure you are in the Global Administrator role in the tenant. The script may prompt you to log in. Open Powershell as administrator. Copy the script by clicking on the copy icon in the script below. Paste the script on the Powershell window and hit enter. </p> <pre><code># Author - Ashish Gupta\n# This script creates a new Azure AD application and sets the Application and Delegated permissions for O365\n\n$TenantDetails = $NULL\n$CurrentlyLoggedInUser = $NULL\n$OnMicrosoftDomain = $NULL\n$connection = $NULL\ntry { \n        $AzureADSession = Get-AzureADCurrentSessionInfo\n        $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n        Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n        $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n    } \n    catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { \n    Write-Host \"You're not connected to AzureAD. Connecting now...\"; \n    $connection = Connect-AzureAD\n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n    $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n    }\n\n$CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\")\n$ApplicationDisplayName = \"Splunk App for Office 365\"\n\n$AzureADAppForSplunk = Get-AzureADApplication -Filter \"DisplayName eq '$ApplicationDisplayName'\"\n\nif($AzureADAppForSplunk -eq $NULL) {\n    write-output(\"AzureAD application \" + $ApplicationDisplayName + \" does not exist. Creating...\")\n\n    #  Get the service principal for O365 and Microsoft Graph\n    $ServicePrincipalO365API        = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Office 365 Management APIs\" }\n    $ServicePrincipalMicrosoftGraph = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Microsoft Graph\" }\n\n    # Get all application permissions for Microsoft Graph\n    $ServicePrincipalMicrosoftGraphAppRoles = $ServicePrincipalMicrosoftGraph.AppRoles | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"}\n\n    # Get all delegated permissions for Microsoft Graph\n    $ServicePrincipalMicrosoftGraphDelegatedRoles = $ServicePrincipalMicrosoftGraph.Oauth2Permissions | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"}\n\n\n    # Get all application permissions for O365 API\n    $ServicePrincipalO365APIAppRoles = $ServicePrincipalO365API.AppRoles | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"}\n\n\n    # Get all delegated permissions for O365 API\n    $ServicePrincipalO365APIDelegatedRoles = $ServicePrincipalO365API.Oauth2Permissions | Where-Object {$_.Value -match \"\\bActivityFeed.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"}\n\n\n    # Create a Required Resource Access object for Office 365\n    $RequiredResourceAccessO365API = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\"\n    $RequiredResourceAccessO365API.ResourceAppId = $ServicePrincipalO365API.AppId\n\n\n    # Create a Required Resource Access object for Microsoft Graph\n    $RequiredResourceAccessMicrosoftGraph = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\"\n    $RequiredResourceAccessMicrosoftGraph.ResourceAppId = $ServicePrincipalMicrosoftGraph.AppId\n\n\n\n    $ServicePrincipalO365APIAppRolesSelectedPermissions = @()\n    $ServicePrincipalSelectedPermissionsMicrosoftGraph = @()\n\n\n    # Get all the Resource Access objects for the Application permissions for Office 365 API\n    Write-output \"Get all the Resource Access objects for the Application permissions for Office 365 API\"\n    foreach ($ServicePrincipalO365APIAppRole in $ServicePrincipalO365APIAppRoles)\n    {\n        $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIAppRole.Id,\"Role\"\n        $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission\n    }\n\n    # Get all the Resource Access objects for the Delegated permissions for Office 365 API\n    Write-output \"Get all the Resource Access objects for the Delegated permissions for Office 365 API\"\n    foreach ($ServicePrincipalO365APIDelegatedRole in $ServicePrincipalO365APIDelegatedRoles) \n    {\n        $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIDelegatedRole.Id,\"Scope\"\n        $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission\n\n    }\n\n    # Get all the Resource Access objects for the Application permissions for Microsoft Graph API\n    Write-Output \"Get all the Resource Access objects for the Application permissions for Microsoft Graph API\"\n    foreach ($ServicePrincipalMicrosoftGraphAppRole in $ServicePrincipalMicrosoftGraphAppRoles)\n    {\n        $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphAppRole.Id,\"Role\"\n        $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission\n    }\n\n    # Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API\n    Write-Output \"Get all the Resource Access objects for the Delegated permissions for Microsoft Graph API\"\n    foreach ($ServicePrincipalMicrosoftGraphDelegatedRole in $ServicePrincipalMicrosoftGraphDelegatedRoles) \n    {\n        $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphDelegatedRole.Id,\"Scope\"\n        $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission\n    }\n\n    # Assign all the permissions to the required Resource access for the O365 API \n    $RequiredResourceAccessO365API.ResourceAccess  = $ServicePrincipalO365APIAppRolesSelectedPermissions\n    # Assign all the permissions to the required Resource access for the Microsoft Graph \n    $RequiredResourceAccessMicrosoftGraph.ResourceAccess = $ServicePrincipalSelectedPermissionsMicrosoftGraph\n\n    # Create the Password credential for the new app\n    Add-Type -AssemblyName System.Web\n    $ApplicationPassword =[System.Web.Security.Membership]::GeneratePassword(32,2)\n    $ApplicationPassword = $ApplicationPassword.Replace(\"+\",\"_\")\n    $ApplicationPassword = $ApplicationPassword.Replace(\"-\",\"_\")\n    $keyId = (New-Guid).ToString();\n    $fromDate = [System.DateTime]::Now\n    $durationInYears = 5\n    $endDate = $fromDate.AddYears($durationInYears) \n    $Applicationkey = New-Object Microsoft.Open.AzureAD.Model.PasswordCredential($null, $endDate, $keyId, $fromDate, $ApplicationPassword)\n\n    # Create the new app with the password cred\n    $aadApplication = New-AzureADApplication -DisplayName $ApplicationDisplayName -PasswordCredentials $Applicationkey\n\n    write-output(\"Application created\")\n\n    # Set the permissions\n    Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $RequiredResourceAccessO365API,$RequiredResourceAccessMicrosoftGraph\n    write-output(\"Application permissions set\")\n\n    # Saving the details for the app\n    $temp_location = (get-location).Drive.Root+\"office365_temp\\\"\n    $temp_file = $temp_location + $CurrentTimestamp+\".txt\"\n    New-Item $temp_location -ItemType Directory -Force | Out-Null\n    New-Item $temp_file -ItemType File -Force | Out-Null\n    Add-Content $temp_file (\"Azure AD App display name: \" + $aadApplication.DisplayName)\n    Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain)\n    Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId)\n    Add-Content $temp_file (\"App ClientId: \" + $aadApplication.AppId)\n    Add-Content $temp_file (\"App Password: \" + $ApplicationPassword)\n    .\\notepad.exe $temp_file\n    write-output(\"Application details written to the file\")\n\n}else{\n    write-output(\"AzureAD application '\" + $AzureADAppForSplunk.DisplayName + \"' already exists.\")\n}\n</code></pre> <p> The powershell script got executed and we can see the newly created app in the Azure portal:    </p>"},{"location":"SetupAzureADAppForSplunk/#step-2-provide-app-details-to-splunk-admin","title":"Step 2 - Provide app details to Splunk Admin","text":"<p>The file containing details for the newly created app is opened in the Notepad. This should be sent to the Splunk Administrator so they could set up the Splunk Add-on for O365 for this tenant.  </p>"},{"location":"SetupAzureADAppForSplunk/#step-3-grant-admin-consent-in-azure-portal","title":"Step 3 - Grant Admin Consent in Azure Portal","text":"<p>Log in to the Azure portal as Global Administrator. Navigate to Azure Active Directory &gt; App Registrations &gt; Click on \"All Applications\" &gt; Go to \"Splunk app for Office 365\". In the app, click on \"API Permissions\".  Notice all the permissions have already been assigned via the script. Click on \"Grant admin consent for tenant\"   After the admin consent grant, It should look like the below : </p>"},{"location":"SetupAzureADAppForSplunk/#create-the-azure-ad-app-for-spunk-add-on-for-microsoft-azure","title":"Create the Azure AD app for Spunk Add-on for Microsoft Azure","text":""},{"location":"SetupAzureADAppForSplunk/#step-1-powershell-script-to-create-the-app_1","title":"Step 1 - PowerShell script to Create the app","text":"<p>Please ensure you are in the Global Administrator role in the tenant. The script may prompt you to log in. Open Powershell as administrator. Copy the script by clicking on the copy icon in the script below. Paste the script on the Powershell window and hit enter.</p> <pre><code>$TenantDetails = $NULL\n$CurrentlyLoggedInUser = $NULL\n$OnMicrosoftDomain = $NULL\n$connection = $NULL\ntry { \n        $AzureADSession = Get-AzureADCurrentSessionInfo\n        $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n        Write-Host \"Already connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n        $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n    } \n    catch [Microsoft.Open.Azure.AD.CommonLibrary.AadNeedAuthenticationException] { \n    Write-Host \"You're not connected to AzureAD. Connecting now...\"; \n    $connection = Connect-AzureAD\n    $AzureADSession = Get-AzureADCurrentSessionInfo\n    $CurrentlyLoggedInUser = $AzureADSession.Account | select -ExpandProperty Id\n    Write-Host \"Connected to : $AzureADSession.TenantDomain as $CurrentlyLoggedInUser\"\n    $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId\n    }\n\n$CurrentTimestamp = [DateTime]::Now.ToString(\"yyyyMMdd-HHmmss\")\n$ApplicationDisplayName = \"Splunk App for Azure\"\n\n$AzureADAppForSplunk = Get-AzureADApplication -Filter \"DisplayName eq '$ApplicationDisplayName'\"\n\nif($AzureADAppForSplunk -eq $NULL) {\n    write-output(\"AzureAD application \" + $ApplicationDisplayName + \" does not exist. Creating...\")\n\n    #  Get the service principal for Microsoft Graph\n    $ServicePrincipalMicrosoftGraph = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Microsoft Graph\" }\n\n    # Get all application permissions for Microsoft Graph\n    $ServicePrincipalMicrosoftGraphAppRoles = $ServicePrincipalMicrosoftGraph.AppRoles | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bUser.Read.All\\b|\\bGroup.Read.All\\b|\\bDevice.Read.All\\b|\\bGroupMember.Read.All\\b|\\bIdentityRiskEvent.Read.All\\b\"}\n\n    # Create a Required Resource Access object for Microsoft Graph\n    $RequiredResourceAccessMicrosoftGraph = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\"\n    $RequiredResourceAccessMicrosoftGraph.ResourceAppId = $ServicePrincipalMicrosoftGraph.AppId\n\n    $ServicePrincipalSelectedPermissionsMicrosoftGraph = @()\n\n    # Get all the Resource Access objects for the Application permissions for Microsoft Graph API\n    Write-Output \"Get all the Resource Access objects for the Application permissions for Microsoft Graph API\"\n    foreach ($ServicePrincipalMicrosoftGraphAppRole in $ServicePrincipalMicrosoftGraphAppRoles)\n    {\n        $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalMicrosoftGraphAppRole.Id,\"Role\"\n        $ServicePrincipalSelectedPermissionsMicrosoftGraph += $Permission\n    }\n\n    # Assign all the permissions to the required Resource access for the Microsoft Graph \n    $RequiredResourceAccessMicrosoftGraph.ResourceAccess = $ServicePrincipalSelectedPermissionsMicrosoftGraph\n\n    # Create the Password credential for the new app\n    Add-Type -AssemblyName System.Web\n    $ApplicationPassword =[System.Web.Security.Membership]::GeneratePassword(32,2)\n    $ApplicationPassword = $ApplicationPassword.Replace(\"+\",\"_\")\n    $ApplicationPassword = $ApplicationPassword.Replace(\"-\",\"_\")\n    $keyId = (New-Guid).ToString();\n    $fromDate = [System.DateTime]::Now\n    $durationInYears = 5\n    $endDate = $fromDate.AddYears($durationInYears) \n    $Applicationkey = New-Object Microsoft.Open.AzureAD.Model.PasswordCredential($null, $endDate, $keyId, $fromDate, $ApplicationPassword)\n\n    # Create the new app with the password cred\n    $aadApplication = New-AzureADApplication -DisplayName $ApplicationDisplayName -PasswordCredentials $Applicationkey\n\n    write-output(\"Application created\")\n\n    # Set the permissions\n    Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $RequiredResourceAccessMicrosoftGraph\n    write-output(\"Application permissions set\")\n\n    # Saving the details for the app\n    $temp_location = (get-location).Drive.Root+\"office365_temp\\\"\n    $temp_file = $temp_location + $CurrentTimestamp+\".txt\"\n    New-Item $temp_location -ItemType Directory -Force | Out-Null\n    New-Item $temp_file -ItemType File -Force | Out-Null\n    Add-Content $temp_file (\"Azure AD App display name: \" + $aadApplication.DisplayName)\n    Add-Content $temp_file (\"Tenant Domain: \" + $AzureADSession.TenantDomain)\n    Add-Content $temp_file (\"Tenant Id: \" + $AzureADSession.TenantId)\n    Add-Content $temp_file (\"App ClientId: \" + $aadApplication.AppId)\n    Add-Content $temp_file (\"App Password: \" + $ApplicationPassword)\n    .\\notepad.exe $temp_file\n    write-output(\"Application details written to the file\")\n\n}else{\n    write-output(\"AzureAD application '\" + $AzureADAppForSplunk.DisplayName + \"' already exists.\")\n}\n</code></pre> <p> The powershell script got executed and we can see the newly created app in the Azure portal:  </p>"},{"location":"SetupAzureADAppForSplunk/#step-2-provide-app-details-to-splunk-admin_1","title":"Step 2 - Provide app details to Splunk Admin","text":"<p>The file containing details for the newly created app is opened in the Notepad. This should be sent to the Splunk Administrator so they could set up the Splunk Add-on for O365 for this tenant.  </p>"},{"location":"SetupAzureADAppForSplunk/#step-3-grant-admin-consent-in-azure-portal_1","title":"Step 3 - Grant Admin Consent in Azure Portal","text":"<p>Log in to the Azure portal as Global Administrator. Navigate to Azure Active Directory &gt; App Registrations &gt; Click on \"All Applications\" &gt; Go to \"Splunk app for Office 365\". In the app, click on \"API Permissions\".  Notice all the permissions have already been assigned via the script. Click on \"Grant admin consent for tenant\"   After the admin consent grant, It should look like the below : </p>"},{"location":"SetupAzureADAppForSplunk/#azure-ad-apps-for-splunk-add-ons-created","title":"Azure AD apps for Splunk add-ons created","text":"<p>  :exclamation: Please coordinate with the Splunk administrator to make sure the Splunk apps have been installed and configured using  the information from the Azure AD apps created above.</p>"},{"location":"SetupTenantProperties/","title":"Set Tenant Properties","text":"<p>Make sure the information under tenant properties is up-to-date. Login to Azure portal &gt; Azure Active Directory  If the global privacy contact is set to blank, Microsoft sends relevant incident emails to all global administrators. </p>"}]}