{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Overview"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"BlockOFACCountries/","text":"Conditional access policy to block access from OFAC countries to all apps for all users except the current logged in user # Connect to AzureAD and get current logged in user $Connection = Connect-AzureAD $CurrentlyLoggedInUser = $connection.Account | select -ExpandProperty Id $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId # Create a named location policy $NamedLocationPolicy = New-AzureADMSNamedLocationPolicy -OdataType \"#microsoft.graph.countryNamedLocation\" -DisplayName \"OFAC Countries\" -CountriesAndRegions \"BY\",\"BI\",\"BA\",\"CD\",\"CF\",\"CI\",\"CN\",\"CU\",\"IQ\",\"IR\",\"KP\",\"LR\",\"MD\",\"ME\",\"MK\",\"NI\",\"RU\",\"RS\",\"SD\",\"SS\",\"SY\",\"UA\",\"VE\",\"YE\",\"ZW\",\"AU\" -IncludeUnknownCountriesAndRegions $false # Create the conditional access policy to block access from all OFAC countries to all apps for all users except the currently logged in user $conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet $conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition $conditions.Applications.IncludeApplications = \"all\" $conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition $conditions.Users.IncludeUsers = \"all\" $conditions.Users.ExcludeUsers = $CurrentUserId $conditions.Locations = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessLocationCondition $conditions.Locations.IncludeLocations = $NamedLocationPolicy.Id $controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls $controls._Operator = \"OR\" $controls.BuiltInControls = \"block\" New-AzureADMSConditionalAccessPolicy -DisplayName \"Block OFAC countries\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls","title":"Block OFAC Countries"},{"location":"CreateEmergencyUser/","text":"# Create an emergency user # Create an emergency user $EmergencyUserUPNPrefix = \"EmUser4\" $UserDisplayName = \"EmergencyUser\" $Connection = Connect-AzureAD $TenantDomain = $Connection.TenantDomain $CurrentlyLoggedInUser = $connection.Account | select -ExpandProperty Id $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId $CurrentlyLoggedInUser = $connection.Account | select -ExpandProperty Id $OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@')) $UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain Add-Type -AssemblyName System.Web $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2) $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile $PasswordProfile.Password = $UserPassword $UserPassword $NewUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\" # Adding the new user to Global Admin role $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq \"Global Administrator\"} Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $NewUser.ObjectId","title":"Create Emergency User"},{"location":"DisableBasicAuth/","text":"Disable Basic Authentication We create an authentication policy which has by default basic auth disabled for all protocols. And the set the default authentication policy for the whole organization the newly created authentication policy New-AuthenticationPolicy \"Disable all BasicAuth\" Set-OrganizationConfig -DefaultAuthenticationPolicy \"Disable all BasicAuth\" Check the newly created authentication policy : The default authentication policy is set to the newly created authentication policy. Get-OrganizationConfig | select DefaultAuthenticationPolicy We can also check the Microsoft Admin Center. Go to Microsoft 365 Admin Center Settings > Org Settings > Modern Authentication All the settings except the \"Turn on modern authentication for Outlook 2013 for Windows and later (recommended)\" should be unchecked.","title":"Disable basic authentication"},{"location":"EnableSelfServicePasswordReset/","text":"","title":"Enable Self Service Password Reset"},{"location":"ImplementMFA/","text":"Create a conditional Acesss Policy to enforce all MFA on all users excluding an emergency Azure cloud-only Account $EmergencyUser = $null $Connection = Connect-AzureAD $TenantDomain = $Connection.TenantDomain $CurrentlyLoggedInUser = $connection.Account | select -ExpandProperty Id $CurrentUserId = Get-AzureADUser -Filter \"UserPrincipalName eq '$CurrentlyLoggedInUser'\" | select -ExpandProperty ObjectId $CurrentlyLoggedInUser = $connection.Account | select -ExpandProperty Id $OnMicrosoftDomain = $CurrentlyLoggedInUser.substring($CurrentlyLoggedInUser.IndexOf('@')) try { $EmergencyUser = Get-AzureAdUser -ObjectId 'EmUser@redteamsimulation.onmicrosoft.com' } catch { # Create an emergency user $EmergencyUserUPNPrefix = \"EmUser\" $UserDisplayName = \"EmergencyUser\" $UserPrincipalName = $EmergencyUserUPNPrefix+$OnMicrosoftDomain Add-Type -AssemblyName System.Web $UserPassword = [System.Web.Security.Membership]::GeneratePassword(32,2) $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile $PasswordProfile.Password = $UserPassword $UserPassword $EmergencyUser = New-AzureADUser -DisplayName $UserDisplayName -PasswordProfile $PasswordProfile -AccountEnabled $true -UserPrincipalName $UserPrincipalName -MailNickName \"EmUser\" # Adding the new user to Global Admin role $GlobalAdminRole = Get-AzureADDirectoryRole | Where-Object { $_.displayName -eq \"Global Administrator\"} Add-AzureADDirectoryRoleMember -ObjectId $GlobalAdminRole.ObjectId -RefObjectId $EmergencyUser.ObjectId } $conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet $conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition $conditions.Applications.IncludeApplications = \"all\" $conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition $conditions.Users.IncludeUsers = \"all\" $conditions.Users.ExcludeUsers = $EmergencyUser.ObjectId $controls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls $controls._Operator = \"OR\" $controls.BuiltInControls = \"mfa\" New-AzureADMSConditionalAccessPolicy -DisplayName \"Enforce MFA on all users\" -State \"Enabled\" -Conditions $conditions -GrantControls $controls","title":"Implement MFA"},{"location":"RestrictExtarnelCollaboration/","text":"","title":"Restrict Extarnel Collaboration"},{"location":"SetupAzureADAppForSplunk/","text":"# Author - Ashish Gupta # This script creates a new Azure AD application and sets the Application and Delegated permissions for specific API (O365) $CurrentDateTime = Get-Date -UFormat \"%Y-%m-%d_%H-%m-%S\" $ApplicationDisplayName = \"Splunk Office 365 App_\" +$CurrentDateTime # Get the service principal for O365 and Microsoft Graph $ServicePrincipalO365API = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Office 365 Management APIs\" } $ServicePrincipalMicrosoftGraph = Get-AzureADServicePrincipal -All $true | ? { $_.DisplayName -eq \"Microsoft Graph\" } # Get all application permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphAppRoles = $ServicePrincipalMicrosoftGraph.AppRoles | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all delegated permissions for Microsoft Graph $ServicePrincipalMicrosoftGraphDelegatedRoles = $ServicePrincipalMicrosoftGraph.Oauth2Permissions | Where-Object {$_.Value -match \"\\bDirectory.Read.All\\b|\\bAuditLog.Read.All\\b|\\bPolicy.Read.All\\b|\\bReports.Read.All\\b\"} # Get all application permissions for O365 API $ServicePrincipalO365APIAppRoles = $ServicePrincipalO365API.AppRoles | Where-Object {$_.Value -match \"\\bActivityReports.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Get all delegated permissions for O365 API $ServicePrincipalO365APIDelegatedRoles = $ServicePrincipalO365API.Oauth2Permissions | Where-Object {$_.Value -match \"\\bActivityReports.Read\\b|\\bActivityFeed.ReadDlp\\b|\\bServiceHealth.Read\\b\"} # Create a Required Resource Access object for Office 365 $RequiredResourceAccessO365API = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\" $RequiredResourceAccessO365API.ResourceAppId = $ServicePrincipalO365API.AppId $ServicePrincipalO365APIAppRolesSelectedPermissions = @() # Get all the Resource Access objects for the Application permissions foreach ($ServicePrincipalO365APIAppRole in $ServicePrincipalO365APIAppRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIAppRole.Id,\"Role\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Get all the Resource Access objects for the Delegated permissions foreach ($ServicePrincipalO365APIDelegatedRole in $ServicePrincipalO365APIDelegatedRoles) { $Permission = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $ServicePrincipalO365APIDelegatedRole.Id,\"Scope\" $ServicePrincipalO365APIAppRolesSelectedPermissions += $Permission } # Assign all the permissions to the required Resource access for the O365 API $RequiredResourceAccessO365API.ResourceAccess = $ServicePrincipalO365APIAppRolesSelectedPermissions # Create the Password credential for the new app Add-Type -AssemblyName System.Web $ApplicationPassword =[System.Web.Security.Membership]::GeneratePassword(32,2) $ApplicationPassword = $ApplicationPassword.Replace(\"+\",\"_\") $ApplicationPassword = $ApplicationPassword.Replace(\"-\",\"_\") $keyId = (New-Guid).ToString(); $fromDate = [System.DateTime]::Now $durationInYears = 5 $endDate = $fromDate.AddYears($durationInYears) $Applicationkey = New-Object Microsoft.Open.AzureAD.Model.PasswordCredential($null, $endDate, $keyId, $fromDate, $ApplicationPassword) # Create the new app with the password cred $aadApplication = New-AzureADApplication -DisplayName $ApplicationDisplayName -PasswordCredentials $Applicationkey write-output(\"Application created\") # Set the permissions Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $RequiredResourceAccessO365API write-output(\"Application permissions set\")","title":"Setup AzureAD App For Splunk"}]}